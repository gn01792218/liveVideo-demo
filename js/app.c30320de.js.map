{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/App.vue?5de1","webpack:///./src/App.vue?c6fb","webpack:///./src/views/Home.vue?557e","webpack:///./src/components/videoLoading.vue","webpack:///./src/components/videoLoading.vue?ff0d","webpack:///./src/videoStreamList.ts","webpack:///./src/components/Video.vue?8828","webpack:///./src/components/Video.vue","webpack:///./src/views/Home.vue?4912","webpack:///./src/views/Home.vue","webpack:///./src/App.vue?47b3","webpack:///./src/App.vue","webpack:///./src/webSocket.ts","webpack:///./src/router/index.ts","webpack:///./src/store/lobby.ts","webpack:///./src/store/auth.ts","webpack:///./src/store/table.ts","webpack:///./src/store/index.ts","webpack:///./src/assets/js/bundle.js","webpack:///./src/socketApi.ts","webpack:///./src/main.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","jsonpScriptSrc","p","exports","module","l","e","promises","installedChunkData","promise","Promise","resolve","reject","onScriptComplete","script","document","createElement","charset","timeout","nc","setAttribute","src","error","Error","event","onerror","onload","clearTimeout","chunk","errorType","type","realSrc","target","message","name","request","undefined","setTimeout","head","appendChild","all","m","c","d","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","oe","err","console","jsonpArray","window","oldJsonpFunction","slice","_hoisted_1","class","render","_ctx","_cache","$props","$setup","$data","$options","_component_Home","_component_Video","__exports__","videoList","stream","_hoisted_2","id","width","height","_hoisted_3","_hoisted_4","_hoisted_5","setup","__props","inputVideoStream","flvStream","loadingVideo","np","NodePlayer","startPlay","setKeepScreenOn","start","stopPlay","stop","clearView","switchVideo","videoStream","log","setView","setScaleMode","setBufferTime","on","w","addEventListener","videoLoading","placeholder","$event","onKeypress","videoStreamList","video","onClick","components","Video","Home","Socket","setIntervalWesocketPush","routes","path","component","router","history","state","LobbyInfo","tableAUid","tableBuid","actions","mutations","payload","tables","uuid","getters","namespaced","userToken","LoginRecall","UserInfo","userWalletFomate","setUserToken","user","wallet","toString","replace","TableJoinRecall","table","betStatus","streamingUrl","lobby","auth","url","onopenWs","onerrorWs","close","clearInterval","readyState","createSocket","oncloseWs","alert","connecting","send","sendWSPush","onmessageWs","msg","dispatchEvent","CustomEvent","detail","WebSocket","binaryType","onopen","onmessage","onclose","$Reader","$protobuf","$Writer","$util","$root","LoginCall","properties","keys","this","header","token","encode","writer","foundation","Header","uint32","fork","ldelim","string","encodeDelimited","decode","reader","end","len","pos","tag","skipType","decodeDelimited","verify","isString","fromObject","TypeError","String","toObject","options","defaults","toJSON","constructor","toJSONOptions","status","int32","isInteger","User","double","Number","json","isFinite","bet","valuesById","values","BetArea","BetStatus","Banker","Player","BankerPair","Tie","PlayerPair","BetCall","gameUuid","betIndex","betArea","enums","BetRecall","totalBets","betError","BetError","BetResetCall","BetResetRecall","errorMessage","dealer","Suit","Card","suit","point","Side","Draw","side","position","card","RoundStartCall","RoundEndCall","RoundStartRecall","RoundEndRecall","BroadcastDealerRoundEnd","Result","GameResult","results","emptyArray","totalWin","end2","Array","isArray","arrays","GameStatus","isGaming","bool","Boolean","uri","route","URI","HeartbeatPing","HeartbeatPong","Message","game","Status","BetRoundStart","timeRemain","BetRoundCountdown","BetRoundEnd","draws","TableInfo","roadmap","Block","Column","blocks","BeadPlate","BigRoad","columns","Roadmap","beadPlate","bigRoad","Table","TableJoinCall","BankerNatural","PlayerNatural","proto","bytes","finish","Uint8Array","loginRecall","commit","lobbyInfo","load","App","use","mount"],"mappings":"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","file":"js/app.c30320de.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"js/\" + ({\"about\":\"about\"}[chunkId]||chunkId) + \".\" + {\"about\":\"b4dbbf09\"}[chunkId] + \".js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\t// create error before stack unwound to get useful stacktrace later\n \t\t\t\tvar error = new Error();\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n \t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tdocument.head.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/liveVideo-demo/\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--9-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!../node_modules/vue-loader-v16/dist/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--9-oneOf-1-2!../node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--1-0!../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./App.vue?vue&type=style&index=0&id=2e1e64c0&lang=scss\"","import { resolveComponent as _resolveComponent, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nconst _hoisted_1 = { class: \"app\" }\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  const _component_Home = _resolveComponent(\"Home\")!\n\n  return (_openBlock(), _createElementBlock(\"div\", _hoisted_1, [\n    _createVNode(_component_Home)\n  ]))\n}","import { resolveComponent as _resolveComponent, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nconst _hoisted_1 = { class: \"home\" }\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  const _component_Video = _resolveComponent(\"Video\")!\n\n  return (_openBlock(), _createElementBlock(\"div\", _hoisted_1, [\n    _createVNode(_component_Video)\n  ]))\n}","<template>\n    <div class=\"video-loading\">\n    </div>\n</template>\n\n","import { render } from \"./videoLoading.vue?vue&type=template&id=f4589534\"\nconst script = {}\n\nimport exportComponent from \"C:\\\\Users\\\\gn017\\\\Desktop\\\\baccart-videodemo\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import {Video} from './types/video/video'\nconst videoList:Video[] = [\n    {\n        name:'video1',\n        stream:\"https://v1.gamenow.online/live?app=bwtc&stream=watch01\",\n    },\n    {\n        name:'video2',\n        stream:\"http://v1.gamenow.online/live?app=gts&stream=cmpV1P\"\n    },\n    {\n        name:'video3',\n        stream:'http://35.201.183.73/live?app=KH89&stream=tt1',\n    },\n]\nexport default videoList","import { defineComponent as _defineComponent } from 'vue'\nimport { createElementVNode as _createElementVNode, vShow as _vShow, createVNode as _createVNode, withDirectives as _withDirectives, vModelText as _vModelText, withKeys as _withKeys, unref as _unref, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString } from \"vue\"\n\nconst _hoisted_1 = { class: \"vd\" }\nconst _hoisted_2 = /*#__PURE__*/_createElementVNode(\"canvas\", {\n  id: \"video\",\n  width: \"980\",\n  height: \"588\"\n}, null, -1)\nconst _hoisted_3 = /*#__PURE__*/_createElementVNode(\"br\", null, null, -1)\nconst _hoisted_4 = { class: \"videoBtnGroup\" }\nconst _hoisted_5 = [\"onClick\"]\n\nimport { onMounted, ref } from \"vue\";\nimport { useStore } from \"vuex\";\nimport videoLoading from \"@/components/videoLoading.vue\";\nimport videoStreamList from \"@/videoStreamList\";\n//直播物件\n\nexport default /*#__PURE__*/_defineComponent({\n  setup(__props) {\n\nconst inputVideoStream = ref('')\nconst flvStream = ref(\"https://v1.gamenow.online/live?app=bwtc&stream=watch01\");\nconst loadingVideo = ref(true);\n//vuex\nconst store = useStore();\n//初始化\nlet np = new NodePlayer();\nonMounted(() => {\n  console.log(\"初始化\");\n  np.setView(\"video\");\n  np.setScaleMode(1);\n  np.setBufferTime(300);\n  np.on(\"error\", (e) => {\n    console.log(\"直播發生錯誤\", e);\n  });\n  np.on(\"videoInfo\", (w) => {\n    console.log(\"顯示Video\", w);\n    loadingVideo.value = false;\n  });\n  np.on(\"stop\", () => {\n    console.log(\"結束播放Video\");\n    loadingVideo.value = true;\n  });\n  startPlay();\n});\nfunction startPlay() {\n  // console.log(\"LiveVideo開始撥放\", testPlayUrl);\n  np.setKeepScreenOn();\n  np.start(flvStream.value);\n  // np.start(testPlayUrl); //測試時使用，播放兔寶寶\n}\nfunction stopPlay() {\n  np.stop();\n  np.clearView(); //清除上一個視頻留下的東西\n}\nfunction switchVideo(videoStream: string) {\n  flvStream.value = videoStream;\n  stopPlay();\n  startPlay();\n  if(inputVideoStream.value) inputVideoStream.value = ''\n}\n//解決視窗失焦掉秒數問題\nwindow.addEventListener(\"focus\", () => {\n  if (np) {\n    console.log('執行')\n    stopPlay();\n    startPlay();\n  }\n});\n\nreturn (_ctx: any,_cache: any) => {\n  return (_openBlock(), _createElementBlock(\"div\", _hoisted_1, [\n    _hoisted_2,\n    _hoisted_3,\n    _withDirectives(_createVNode(videoLoading, null, null, 512), [\n      [_vShow, loadingVideo.value]\n    ]),\n    _withDirectives(_createElementVNode(\"input\", {\n      class: \"streamInput\",\n      placeholder: \"請輸入視訊網址\",\n      type: \"text\",\n      \"onUpdate:modelValue\": _cache[0] || (_cache[0] = ($event: any) => ((inputVideoStream).value = $event)),\n      onKeypress: _cache[1] || (_cache[1] = _withKeys(($event: any) => (switchVideo(inputVideoStream.value)), [\"enter\"]))\n    }, null, 544), [\n      [_vModelText, inputVideoStream.value]\n    ]),\n    _createElementVNode(\"div\", _hoisted_4, [\n      (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(videoStreamList), (video) => {\n        return (_openBlock(), _createElementBlock(\"button\", {\n          class: \"videoBtn\",\n          key: video.name,\n          onClick: ($event: any) => (switchVideo(video.stream))\n        }, _toDisplayString(video.name), 9, _hoisted_5))\n      }), 128))\n    ])\n  ]))\n}\n}\n\n})","import script from \"./Video.vue?vue&type=script&setup=true&lang=ts\"\nexport * from \"./Video.vue?vue&type=script&setup=true&lang=ts\"\n\nconst __exports__ = script;\n\nexport default __exports__","\nimport {computed, defineComponent,ref, reactive, onMounted, watch} from 'vue'\nimport {useStore} from 'vuex'\nimport {useRoute,useRouter } from 'vue-router'\nimport {createSocket} from '../webSocket'\nimport {sendLogin , sendTableJoinCall ,} from '../socketApi'\nimport Video from '@/components/Video.vue'; // @ is an alias to /src\nexport default defineComponent({\n  components:{\n    Video,\n  },\n    setup(){\n    //   const store = useStore()\n    //   const vuexUserToken = computed(()=>{\n    //     return store.state.auth.userToken\n    //   })\n    //   const tables = reactive(computed(()=>{  //桌號uuid\n    //     return store.state.lobby.LobbyInfo\n    //   }))\n    //   const tableRecall = reactive(computed(()=>{  //桌號uuid\n    //     return store.state.table.TableJoinRecall\n    //   }))\n    //   watch(tables,()=>{\n    //     tableJoin ()\n    //   })\n    //   watch(tableRecall,()=>{\n    //     console.log(tableRecall.value)\n    //   })\n    //   const tableNum = ref('A')\n    //   function tableJoin (){\n    //    switch(tableNum.value){\n    //     case 'A':\n    //       for(let i = 0 ; i<tables.value.tables.length ; i++){\n    //         if(tables.value.tables[i].name==\"A桌\"){\n    //           sendTableJoinCall({\n    //             uri:\"TableJoinCall\",\n    //             uuid:tables.value.tables[i].uuid\n    //           })\n    //           console.log(`請求${tableNum.value}桌`,\"桌號:\"+tables.value.tables[i].name,\"uuid:\"+tables.value.tables[i].uuid,\"Loby資訊:\",tables.value)\n    //           break\n    //         }\n    //       }\n    //       break\n    //     case 'B':\n    //        for(let i = 0 ; i<tables.value.tables.length ; i++){\n    //         if(tables.value.tables[i].name==\"B桌\"){\n    //           sendTableJoinCall({\n    //             uri:\"TableJoinCall\",\n    //             uuid:tables.value.tables[i].uuid\n    //           })\n    //           console.log(`請求${tableNum.value}桌`,\"桌號:\"+tables.value.tables[i].name,\"uuid:\"+tables.value.tables[i].uuid,\"Loby資訊:\",tables.value)\n    //           break\n    //         }\n    //       }\n    //   }\n    // }\n    //   //創建連線(再次返回大廳時使用者token已經存在，就不會再創server)\n    //   if(vuexUserToken.value==\"\"){ \n    //     createSocket()\n    //     sendLogin({\n    //       uri: \"LoginCall\",\n    //       token: 'DEV_TOKEN',\n    //     })\n    //   }\n      return{\n          //data\n      }\n    }\n})\n","import { render } from \"./Home.vue?vue&type=template&id=8cd52f80&ts=true\"\nimport script from \"./Home.vue?vue&type=script&lang=ts\"\nexport * from \"./Home.vue?vue&type=script&lang=ts\"\n\nimport exportComponent from \"C:\\\\Users\\\\gn017\\\\Desktop\\\\baccart-videodemo\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","\nimport { defineComponent } from 'vue';\nimport Home from '@/views/Home.vue'\nexport default defineComponent({\n  components: {\n    Home,\n  },\n});\n","import { render } from \"./App.vue?vue&type=template&id=2e1e64c0&ts=true\"\nimport script from \"./App.vue?vue&type=script&lang=ts\"\nexport * from \"./App.vue?vue&type=script&lang=ts\"\n\nimport \"./App.vue?vue&type=style&index=0&id=2e1e64c0&lang=scss\"\n\nimport exportComponent from \"C:\\\\Users\\\\gn017\\\\Desktop\\\\baccart-videodemo\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","\r\nconst url = process.env.VUE_APP_API_HOST;  //後端網址寫在.env檔案中；分為線上環境和測試環境//8199 由keypir控制//8200 可以自由測的\r\n//建立webSocket實例\r\nlet Socket:WebSocket | null\r\nlet setIntervalWesocketPush:number\r\n//websocket方法區\r\n//連接上後會發送心跳\r\nconst onopenWs = ()=>{\r\n    console.log(\"連線建立成功\")\r\n}\r\n//連接失敗會重新連線\r\nconst onerrorWs = ()=>{\r\n    Socket?.close()\r\n    clearInterval(setIntervalWesocketPush)\r\n    if(Socket?.readyState !== 3){ //stateCode 3 為連接已關閉，或沒有連接成功\r\n        Socket = null\r\n        createSocket()\r\n        console.log(\"重連成功\")\r\n    }\r\n}\r\n//監聽關閉\r\nconst oncloseWs = () => {\r\n    clearInterval(setIntervalWesocketPush)\r\n    alert('websocket已斷開....正在嘗試重連')\r\n    if (Socket?.readyState !== 2) {  //readyState 2 = 連接正在關閉\r\n      Socket = null\r\n      createSocket()\r\n    }\r\n  }\r\n\r\n/**\r\n * 发送数据但连接未建立时进行处理等待重发\r\n * @param {any} message 需要发送的数据\r\n */\r\n const connecting = (message:any) => {\r\n    setTimeout(() => {\r\n      if (Socket?.readyState === 0) { //readyState 0 表示正在連接中，那就繼續connecting\r\n        connecting(message)\r\n      } else {\r\n        Socket?.send(message)\r\n        \r\n      }\r\n    }, 1000)\r\n  }\r\n//暴露的方法區\r\n/**\r\n * 发送数据\r\n * @param {any} message 需要发送的数据\r\n */\r\n export const sendWSPush = (message:any) => { //第二個參數，依據不同的lookupType包裝proto\r\n    if (Socket !== null && Socket.readyState === 3) {\r\n      Socket.close()\r\n      createSocket()\r\n    } else if (Socket?.readyState === 1) { //已經連接，且可以通訊\r\n      Socket.send(message)\r\n    } else if (Socket?.readyState === 0) { //正在連接中\r\n      connecting(message)\r\n      console.log(\"readyState:\"+Socket.readyState,\"準備傳送:\"+message);\r\n    }\r\n  }\r\n\r\n  export const onmessageWs=(msg:any)=>{\r\n    if(msg){ \r\n        //註冊一個自訂義的onmessageWs事件，帶header給第二層去處理要裝到哪個Vuex裡面\r\n      window.dispatchEvent(new CustomEvent('onmessageWs',{\r\n          detail:{\r\n            msg\r\n          }\r\n        }))\r\n    }\r\n}\r\n  /**发送心跳\r\n * @param {number} time 心跳间隔毫秒 默认5000\r\n * @param {string} ping 心跳名称 默认字符串ping\r\n */\r\nexport const sendPing = (time = 5500, ping = 'ping') => {\r\n    clearInterval(setIntervalWesocketPush)\r\n    Socket?.send(ping)\r\n    setIntervalWesocketPush = setInterval(() => {\r\n      Socket?.send(ping)\r\n    }, time)\r\n  }\r\n  //建立ws\r\nexport const createSocket =()=>{  //使用createSocket的方法，會自動開啟監聽連線、訊息等等方法\r\n    console.log(\"創建伺服器\")\r\n    Socket && Socket.close()\r\n    if(!Socket){\r\n        Socket = new WebSocket(url);\r\n        Socket.binaryType='arraybuffer' //切記將binaryType設成二進制\r\n        Socket.onopen = onopenWs  //會打開心跳\r\n        Socket.onmessage = onmessageWs    \r\n        Socket.onerror = onerrorWs\r\n        Socket.onclose = oncloseWs\r\n        console.log(\"建立websocket連線\");\r\n    }\r\n}\r\n\r\n\r\n\r\n","import { createRouter, createWebHistory, RouteRecordRaw,createWebHashHistory } from 'vue-router'\nimport Home from '../views/Home.vue'\n\nconst routes: Array<RouteRecordRaw> = [\n  {\n    path: '/',\n    name: 'Home',\n    component: Home\n  },\n  {\n    path: '/about',\n    name: 'About',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () => import(/* webpackChunkName: \"about\" */ '../views/About.vue')\n  }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(process.env.BASE_URL),\n  routes\n})\n\nexport default router\n","\r\nexport const state = {\r\n  LobbyInfo: {\r\n  },\r\n  tableAUid:\"\",\r\n  tableBuid:\"\",\r\n};\r\nexport const actions = {}\r\n\r\nexport const mutations = {\r\n  LobbyInfo(state:any, payload:any) { //接收wbSocket的訊息\r\n    state.LobbyInfo=payload\r\n    // console.log(\"vuex-lobby資料更新\",state.LobbyInfo)\r\n    state.tableAUid = payload.tables[0].uuid\r\n    state.tableBuid = payload.tables[1].uuid\r\n  },\r\n};\r\nexport const getters = {}\r\n\r\nexport default {\r\n  state,\r\n  actions,\r\n  mutations,\r\n  getters,\r\n  namespaced: true,\r\n};","\r\nexport const state = {\r\n  userToken:\"\",\r\n  LoginRecall: {},\r\n  UserInfo:{},\r\n  userWalletFomate:0,\r\n};\r\nexport const actions = {}\r\n\r\nexport const mutations = {\r\n  setUserToken(state:any,payload:string){\r\n    state.userToken = payload\r\n  },\r\n  LoginRecall(state:any, payload:any) { //接收wbSocket的訊息\r\n    state.LoginRecall=payload\r\n    // console.log(\"vuex-auth資料更新\",state.LoginRecall)\r\n  },\r\n  UserInfo(state:any, payload:any) { //接收wbSocket的訊息\r\n    state.UserInfo=payload\r\n    state.userWalletFomate = payload.user.wallet.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g,'$1,')\r\n    // console.log(\"vuex-auth資料更新\",state.UserInfo)\r\n  },\r\n};\r\nexport const getters = {}\r\n\r\nexport default {\r\n  state,\r\n  actions,\r\n  mutations,\r\n  getters,\r\n  namespaced: true,\r\n};","export const state = {\r\n  TableJoinRecall:{\r\n    table:{\r\n      betStatus:{},\r\n      streamingUrl:\"\",\r\n    }\r\n  },\r\n};\r\nexport const actions = {}\r\n\r\nexport const mutations = {\r\n  TableJoinRecall(state:any, payload:any) { //接收wbSocket的訊息\r\n    state.TableJoinRecall=payload\r\n    // console.log(\"vuex-tableInfo資料更新\",state.TableJoinRecall)\r\n  },\r\n};\r\nexport const getters = {\r\n \r\n}\r\n\r\nexport default {\r\n  state,\r\n  actions,\r\n  mutations,\r\n  getters,\r\n  namespaced: true,\r\n};","import { createStore } from 'vuex'\r\nimport lobby from './lobby'\r\nimport auth from './auth'\r\nimport table from './table'\r\n\r\nexport default createStore({\r\n  state: {\r\n  },\r\n  mutations: {\r\n  },\r\n  actions: {\r\n  },\r\n  modules: {\r\n    lobby,auth,table,\r\n  }\r\n})\r\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\nimport * as $protobuf from \"protobufjs/minimal\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\nexport const auth = $root.auth = (() => {\n\n    /**\n     * Namespace auth.\n     * @exports auth\n     * @namespace\n     */\n    const auth = {};\n\n    auth.LoginCall = (function() {\n\n        /**\n         * Properties of a LoginCall.\n         * @memberof auth\n         * @interface ILoginCall\n         * @property {foundation.IHeader|null} [header] LoginCall header\n         * @property {string|null} [token] LoginCall token\n         */\n\n        /**\n         * Constructs a new LoginCall.\n         * @memberof auth\n         * @classdesc Represents a LoginCall.\n         * @implements ILoginCall\n         * @constructor\n         * @param {auth.ILoginCall=} [properties] Properties to set\n         */\n        function LoginCall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LoginCall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof auth.LoginCall\n         * @instance\n         */\n        LoginCall.prototype.header = null;\n\n        /**\n         * LoginCall token.\n         * @member {string} token\n         * @memberof auth.LoginCall\n         * @instance\n         */\n        LoginCall.prototype.token = \"\";\n\n        /**\n         * Creates a new LoginCall instance using the specified properties.\n         * @function create\n         * @memberof auth.LoginCall\n         * @static\n         * @param {auth.ILoginCall=} [properties] Properties to set\n         * @returns {auth.LoginCall} LoginCall instance\n         */\n        LoginCall.create = function create(properties) {\n            return new LoginCall(properties);\n        };\n\n        /**\n         * Encodes the specified LoginCall message. Does not implicitly {@link auth.LoginCall.verify|verify} messages.\n         * @function encode\n         * @memberof auth.LoginCall\n         * @static\n         * @param {auth.ILoginCall} message LoginCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LoginCall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.token != null && Object.hasOwnProperty.call(message, \"token\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LoginCall message, length delimited. Does not implicitly {@link auth.LoginCall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof auth.LoginCall\n         * @static\n         * @param {auth.ILoginCall} message LoginCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LoginCall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LoginCall message from the specified reader or buffer.\n         * @function decode\n         * @memberof auth.LoginCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {auth.LoginCall} LoginCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LoginCall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.auth.LoginCall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.token = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LoginCall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof auth.LoginCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {auth.LoginCall} LoginCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LoginCall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LoginCall message.\n         * @function verify\n         * @memberof auth.LoginCall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LoginCall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.token != null && message.hasOwnProperty(\"token\"))\n                if (!$util.isString(message.token))\n                    return \"token: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a LoginCall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof auth.LoginCall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {auth.LoginCall} LoginCall\n         */\n        LoginCall.fromObject = function fromObject(object) {\n            if (object instanceof $root.auth.LoginCall)\n                return object;\n            let message = new $root.auth.LoginCall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".auth.LoginCall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.token != null)\n                message.token = String(object.token);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LoginCall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof auth.LoginCall\n         * @static\n         * @param {auth.LoginCall} message LoginCall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LoginCall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.token = \"\";\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.token != null && message.hasOwnProperty(\"token\"))\n                object.token = message.token;\n            return object;\n        };\n\n        /**\n         * Converts this LoginCall to JSON.\n         * @function toJSON\n         * @memberof auth.LoginCall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LoginCall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LoginCall;\n    })();\n\n    auth.LoginRecall = (function() {\n\n        /**\n         * Properties of a LoginRecall.\n         * @memberof auth\n         * @interface ILoginRecall\n         * @property {foundation.IHeader|null} [header] LoginRecall header\n         * @property {number|null} [status] LoginRecall status\n         */\n\n        /**\n         * Constructs a new LoginRecall.\n         * @memberof auth\n         * @classdesc Represents a LoginRecall.\n         * @implements ILoginRecall\n         * @constructor\n         * @param {auth.ILoginRecall=} [properties] Properties to set\n         */\n        function LoginRecall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LoginRecall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof auth.LoginRecall\n         * @instance\n         */\n        LoginRecall.prototype.header = null;\n\n        /**\n         * LoginRecall status.\n         * @member {number} status\n         * @memberof auth.LoginRecall\n         * @instance\n         */\n        LoginRecall.prototype.status = 0;\n\n        /**\n         * Creates a new LoginRecall instance using the specified properties.\n         * @function create\n         * @memberof auth.LoginRecall\n         * @static\n         * @param {auth.ILoginRecall=} [properties] Properties to set\n         * @returns {auth.LoginRecall} LoginRecall instance\n         */\n        LoginRecall.create = function create(properties) {\n            return new LoginRecall(properties);\n        };\n\n        /**\n         * Encodes the specified LoginRecall message. Does not implicitly {@link auth.LoginRecall.verify|verify} messages.\n         * @function encode\n         * @memberof auth.LoginRecall\n         * @static\n         * @param {auth.ILoginRecall} message LoginRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LoginRecall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.status != null && Object.hasOwnProperty.call(message, \"status\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LoginRecall message, length delimited. Does not implicitly {@link auth.LoginRecall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof auth.LoginRecall\n         * @static\n         * @param {auth.ILoginRecall} message LoginRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LoginRecall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LoginRecall message from the specified reader or buffer.\n         * @function decode\n         * @memberof auth.LoginRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {auth.LoginRecall} LoginRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LoginRecall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.auth.LoginRecall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.status = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LoginRecall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof auth.LoginRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {auth.LoginRecall} LoginRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LoginRecall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LoginRecall message.\n         * @function verify\n         * @memberof auth.LoginRecall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LoginRecall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.status != null && message.hasOwnProperty(\"status\"))\n                if (!$util.isInteger(message.status))\n                    return \"status: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a LoginRecall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof auth.LoginRecall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {auth.LoginRecall} LoginRecall\n         */\n        LoginRecall.fromObject = function fromObject(object) {\n            if (object instanceof $root.auth.LoginRecall)\n                return object;\n            let message = new $root.auth.LoginRecall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".auth.LoginRecall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.status != null)\n                message.status = object.status | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LoginRecall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof auth.LoginRecall\n         * @static\n         * @param {auth.LoginRecall} message LoginRecall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LoginRecall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.status = 0;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.status != null && message.hasOwnProperty(\"status\"))\n                object.status = message.status;\n            return object;\n        };\n\n        /**\n         * Converts this LoginRecall to JSON.\n         * @function toJSON\n         * @memberof auth.LoginRecall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LoginRecall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LoginRecall;\n    })();\n\n    auth.UserInfo = (function() {\n\n        /**\n         * Properties of a UserInfo.\n         * @memberof auth\n         * @interface IUserInfo\n         * @property {foundation.IHeader|null} [header] UserInfo header\n         * @property {auth.IUser|null} [user] UserInfo user\n         */\n\n        /**\n         * Constructs a new UserInfo.\n         * @memberof auth\n         * @classdesc Represents a UserInfo.\n         * @implements IUserInfo\n         * @constructor\n         * @param {auth.IUserInfo=} [properties] Properties to set\n         */\n        function UserInfo(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * UserInfo header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof auth.UserInfo\n         * @instance\n         */\n        UserInfo.prototype.header = null;\n\n        /**\n         * UserInfo user.\n         * @member {auth.IUser|null|undefined} user\n         * @memberof auth.UserInfo\n         * @instance\n         */\n        UserInfo.prototype.user = null;\n\n        /**\n         * Creates a new UserInfo instance using the specified properties.\n         * @function create\n         * @memberof auth.UserInfo\n         * @static\n         * @param {auth.IUserInfo=} [properties] Properties to set\n         * @returns {auth.UserInfo} UserInfo instance\n         */\n        UserInfo.create = function create(properties) {\n            return new UserInfo(properties);\n        };\n\n        /**\n         * Encodes the specified UserInfo message. Does not implicitly {@link auth.UserInfo.verify|verify} messages.\n         * @function encode\n         * @memberof auth.UserInfo\n         * @static\n         * @param {auth.IUserInfo} message UserInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        UserInfo.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.user != null && Object.hasOwnProperty.call(message, \"user\"))\n                $root.auth.User.encode(message.user, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified UserInfo message, length delimited. Does not implicitly {@link auth.UserInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof auth.UserInfo\n         * @static\n         * @param {auth.IUserInfo} message UserInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        UserInfo.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a UserInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof auth.UserInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {auth.UserInfo} UserInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        UserInfo.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.auth.UserInfo();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.user = $root.auth.User.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a UserInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof auth.UserInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {auth.UserInfo} UserInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        UserInfo.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a UserInfo message.\n         * @function verify\n         * @memberof auth.UserInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        UserInfo.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.user != null && message.hasOwnProperty(\"user\")) {\n                let error = $root.auth.User.verify(message.user);\n                if (error)\n                    return \"user.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a UserInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof auth.UserInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {auth.UserInfo} UserInfo\n         */\n        UserInfo.fromObject = function fromObject(object) {\n            if (object instanceof $root.auth.UserInfo)\n                return object;\n            let message = new $root.auth.UserInfo();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".auth.UserInfo.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.user != null) {\n                if (typeof object.user !== \"object\")\n                    throw TypeError(\".auth.UserInfo.user: object expected\");\n                message.user = $root.auth.User.fromObject(object.user);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a UserInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof auth.UserInfo\n         * @static\n         * @param {auth.UserInfo} message UserInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        UserInfo.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.user = null;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.user != null && message.hasOwnProperty(\"user\"))\n                object.user = $root.auth.User.toObject(message.user, options);\n            return object;\n        };\n\n        /**\n         * Converts this UserInfo to JSON.\n         * @function toJSON\n         * @memberof auth.UserInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        UserInfo.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return UserInfo;\n    })();\n\n    auth.User = (function() {\n\n        /**\n         * Properties of a User.\n         * @memberof auth\n         * @interface IUser\n         * @property {string|null} [name] User name\n         * @property {number|null} [wallet] User wallet\n         */\n\n        /**\n         * Constructs a new User.\n         * @memberof auth\n         * @classdesc Represents a User.\n         * @implements IUser\n         * @constructor\n         * @param {auth.IUser=} [properties] Properties to set\n         */\n        function User(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * User name.\n         * @member {string} name\n         * @memberof auth.User\n         * @instance\n         */\n        User.prototype.name = \"\";\n\n        /**\n         * User wallet.\n         * @member {number} wallet\n         * @memberof auth.User\n         * @instance\n         */\n        User.prototype.wallet = 0;\n\n        /**\n         * Creates a new User instance using the specified properties.\n         * @function create\n         * @memberof auth.User\n         * @static\n         * @param {auth.IUser=} [properties] Properties to set\n         * @returns {auth.User} User instance\n         */\n        User.create = function create(properties) {\n            return new User(properties);\n        };\n\n        /**\n         * Encodes the specified User message. Does not implicitly {@link auth.User.verify|verify} messages.\n         * @function encode\n         * @memberof auth.User\n         * @static\n         * @param {auth.IUser} message User message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        User.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n            if (message.wallet != null && Object.hasOwnProperty.call(message, \"wallet\"))\n                writer.uint32(/* id 2, wireType 1 =*/17).double(message.wallet);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified User message, length delimited. Does not implicitly {@link auth.User.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof auth.User\n         * @static\n         * @param {auth.IUser} message User message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        User.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a User message from the specified reader or buffer.\n         * @function decode\n         * @memberof auth.User\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {auth.User} User\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        User.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.auth.User();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.wallet = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a User message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof auth.User\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {auth.User} User\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        User.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a User message.\n         * @function verify\n         * @memberof auth.User\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        User.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.wallet != null && message.hasOwnProperty(\"wallet\"))\n                if (typeof message.wallet !== \"number\")\n                    return \"wallet: number expected\";\n            return null;\n        };\n\n        /**\n         * Creates a User message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof auth.User\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {auth.User} User\n         */\n        User.fromObject = function fromObject(object) {\n            if (object instanceof $root.auth.User)\n                return object;\n            let message = new $root.auth.User();\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.wallet != null)\n                message.wallet = Number(object.wallet);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a User message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof auth.User\n         * @static\n         * @param {auth.User} message User\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        User.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.name = \"\";\n                object.wallet = 0;\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.wallet != null && message.hasOwnProperty(\"wallet\"))\n                object.wallet = options.json && !isFinite(message.wallet) ? String(message.wallet) : message.wallet;\n            return object;\n        };\n\n        /**\n         * Converts this User to JSON.\n         * @function toJSON\n         * @memberof auth.User\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        User.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return User;\n    })();\n\n    return auth;\n})();\n\nexport const bet = $root.bet = (() => {\n\n    /**\n     * Namespace bet.\n     * @exports bet\n     * @namespace\n     */\n    const bet = {};\n\n    /**\n     * Error enum.\n     * @name bet.Error\n     * @enum {number}\n     * @property {number} ErrorDefault=0 ErrorDefault value\n     * @property {number} BetTimeNotInvlid=1 BetTimeNotInvlid value\n     * @property {number} BetIndexInvalid=2 BetIndexInvalid value\n     * @property {number} BetAreaInvalid=3 BetAreaInvalid value\n     * @property {number} ReachMaxLimit=4 ReachMaxLimit value\n     * @property {number} RoundNotFound=5 RoundNotFound value\n     * @property {number} NoEnoughWallet=6 NoEnoughWallet value\n     */\n    bet.Error = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"ErrorDefault\"] = 0;\n        values[valuesById[1] = \"BetTimeNotInvlid\"] = 1;\n        values[valuesById[2] = \"BetIndexInvalid\"] = 2;\n        values[valuesById[3] = \"BetAreaInvalid\"] = 3;\n        values[valuesById[4] = \"ReachMaxLimit\"] = 4;\n        values[valuesById[5] = \"RoundNotFound\"] = 5;\n        values[valuesById[6] = \"NoEnoughWallet\"] = 6;\n        return values;\n    })();\n\n    /**\n     * BetArea enum.\n     * @name bet.BetArea\n     * @enum {number}\n     * @property {number} BetAreaDefault=0 BetAreaDefault value\n     * @property {number} Player=1 Player value\n     * @property {number} Banker=2 Banker value\n     * @property {number} PlayerPair=3 PlayerPair value\n     * @property {number} Tie=4 Tie value\n     * @property {number} BankerPair=5 BankerPair value\n     */\n    bet.BetArea = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"BetAreaDefault\"] = 0;\n        values[valuesById[1] = \"Player\"] = 1;\n        values[valuesById[2] = \"Banker\"] = 2;\n        values[valuesById[3] = \"PlayerPair\"] = 3;\n        values[valuesById[4] = \"Tie\"] = 4;\n        values[valuesById[5] = \"BankerPair\"] = 5;\n        return values;\n    })();\n\n    bet.BetStatus = (function() {\n\n        /**\n         * Properties of a BetStatus.\n         * @memberof bet\n         * @interface IBetStatus\n         * @property {number|null} [Banker] BetStatus Banker\n         * @property {number|null} [Player] BetStatus Player\n         * @property {number|null} [BankerPair] BetStatus BankerPair\n         * @property {number|null} [Tie] BetStatus Tie\n         * @property {number|null} [PlayerPair] BetStatus PlayerPair\n         */\n\n        /**\n         * Constructs a new BetStatus.\n         * @memberof bet\n         * @classdesc Represents a BetStatus.\n         * @implements IBetStatus\n         * @constructor\n         * @param {bet.IBetStatus=} [properties] Properties to set\n         */\n        function BetStatus(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BetStatus Banker.\n         * @member {number} Banker\n         * @memberof bet.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.Banker = 0;\n\n        /**\n         * BetStatus Player.\n         * @member {number} Player\n         * @memberof bet.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.Player = 0;\n\n        /**\n         * BetStatus BankerPair.\n         * @member {number} BankerPair\n         * @memberof bet.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.BankerPair = 0;\n\n        /**\n         * BetStatus Tie.\n         * @member {number} Tie\n         * @memberof bet.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.Tie = 0;\n\n        /**\n         * BetStatus PlayerPair.\n         * @member {number} PlayerPair\n         * @memberof bet.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.PlayerPair = 0;\n\n        /**\n         * Creates a new BetStatus instance using the specified properties.\n         * @function create\n         * @memberof bet.BetStatus\n         * @static\n         * @param {bet.IBetStatus=} [properties] Properties to set\n         * @returns {bet.BetStatus} BetStatus instance\n         */\n        BetStatus.create = function create(properties) {\n            return new BetStatus(properties);\n        };\n\n        /**\n         * Encodes the specified BetStatus message. Does not implicitly {@link bet.BetStatus.verify|verify} messages.\n         * @function encode\n         * @memberof bet.BetStatus\n         * @static\n         * @param {bet.IBetStatus} message BetStatus message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetStatus.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.Banker != null && Object.hasOwnProperty.call(message, \"Banker\"))\n                writer.uint32(/* id 1, wireType 1 =*/9).double(message.Banker);\n            if (message.Player != null && Object.hasOwnProperty.call(message, \"Player\"))\n                writer.uint32(/* id 2, wireType 1 =*/17).double(message.Player);\n            if (message.BankerPair != null && Object.hasOwnProperty.call(message, \"BankerPair\"))\n                writer.uint32(/* id 3, wireType 1 =*/25).double(message.BankerPair);\n            if (message.Tie != null && Object.hasOwnProperty.call(message, \"Tie\"))\n                writer.uint32(/* id 4, wireType 1 =*/33).double(message.Tie);\n            if (message.PlayerPair != null && Object.hasOwnProperty.call(message, \"PlayerPair\"))\n                writer.uint32(/* id 5, wireType 1 =*/41).double(message.PlayerPair);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BetStatus message, length delimited. Does not implicitly {@link bet.BetStatus.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof bet.BetStatus\n         * @static\n         * @param {bet.IBetStatus} message BetStatus message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetStatus.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BetStatus message from the specified reader or buffer.\n         * @function decode\n         * @memberof bet.BetStatus\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {bet.BetStatus} BetStatus\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetStatus.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.bet.BetStatus();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.Banker = reader.double();\n                    break;\n                case 2:\n                    message.Player = reader.double();\n                    break;\n                case 3:\n                    message.BankerPair = reader.double();\n                    break;\n                case 4:\n                    message.Tie = reader.double();\n                    break;\n                case 5:\n                    message.PlayerPair = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BetStatus message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof bet.BetStatus\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {bet.BetStatus} BetStatus\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetStatus.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BetStatus message.\n         * @function verify\n         * @memberof bet.BetStatus\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BetStatus.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.Banker != null && message.hasOwnProperty(\"Banker\"))\n                if (typeof message.Banker !== \"number\")\n                    return \"Banker: number expected\";\n            if (message.Player != null && message.hasOwnProperty(\"Player\"))\n                if (typeof message.Player !== \"number\")\n                    return \"Player: number expected\";\n            if (message.BankerPair != null && message.hasOwnProperty(\"BankerPair\"))\n                if (typeof message.BankerPair !== \"number\")\n                    return \"BankerPair: number expected\";\n            if (message.Tie != null && message.hasOwnProperty(\"Tie\"))\n                if (typeof message.Tie !== \"number\")\n                    return \"Tie: number expected\";\n            if (message.PlayerPair != null && message.hasOwnProperty(\"PlayerPair\"))\n                if (typeof message.PlayerPair !== \"number\")\n                    return \"PlayerPair: number expected\";\n            return null;\n        };\n\n        /**\n         * Creates a BetStatus message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof bet.BetStatus\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {bet.BetStatus} BetStatus\n         */\n        BetStatus.fromObject = function fromObject(object) {\n            if (object instanceof $root.bet.BetStatus)\n                return object;\n            let message = new $root.bet.BetStatus();\n            if (object.Banker != null)\n                message.Banker = Number(object.Banker);\n            if (object.Player != null)\n                message.Player = Number(object.Player);\n            if (object.BankerPair != null)\n                message.BankerPair = Number(object.BankerPair);\n            if (object.Tie != null)\n                message.Tie = Number(object.Tie);\n            if (object.PlayerPair != null)\n                message.PlayerPair = Number(object.PlayerPair);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BetStatus message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof bet.BetStatus\n         * @static\n         * @param {bet.BetStatus} message BetStatus\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BetStatus.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.Banker = 0;\n                object.Player = 0;\n                object.BankerPair = 0;\n                object.Tie = 0;\n                object.PlayerPair = 0;\n            }\n            if (message.Banker != null && message.hasOwnProperty(\"Banker\"))\n                object.Banker = options.json && !isFinite(message.Banker) ? String(message.Banker) : message.Banker;\n            if (message.Player != null && message.hasOwnProperty(\"Player\"))\n                object.Player = options.json && !isFinite(message.Player) ? String(message.Player) : message.Player;\n            if (message.BankerPair != null && message.hasOwnProperty(\"BankerPair\"))\n                object.BankerPair = options.json && !isFinite(message.BankerPair) ? String(message.BankerPair) : message.BankerPair;\n            if (message.Tie != null && message.hasOwnProperty(\"Tie\"))\n                object.Tie = options.json && !isFinite(message.Tie) ? String(message.Tie) : message.Tie;\n            if (message.PlayerPair != null && message.hasOwnProperty(\"PlayerPair\"))\n                object.PlayerPair = options.json && !isFinite(message.PlayerPair) ? String(message.PlayerPair) : message.PlayerPair;\n            return object;\n        };\n\n        /**\n         * Converts this BetStatus to JSON.\n         * @function toJSON\n         * @memberof bet.BetStatus\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BetStatus.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BetStatus;\n    })();\n\n    bet.BetCall = (function() {\n\n        /**\n         * Properties of a BetCall.\n         * @memberof bet\n         * @interface IBetCall\n         * @property {foundation.IHeader|null} [header] BetCall header\n         * @property {string|null} [gameUuid] BetCall gameUuid\n         * @property {number|null} [betIndex] BetCall betIndex\n         * @property {bet.BetArea|null} [betArea] BetCall betArea\n         */\n\n        /**\n         * Constructs a new BetCall.\n         * @memberof bet\n         * @classdesc Represents a BetCall.\n         * @implements IBetCall\n         * @constructor\n         * @param {bet.IBetCall=} [properties] Properties to set\n         */\n        function BetCall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BetCall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof bet.BetCall\n         * @instance\n         */\n        BetCall.prototype.header = null;\n\n        /**\n         * BetCall gameUuid.\n         * @member {string} gameUuid\n         * @memberof bet.BetCall\n         * @instance\n         */\n        BetCall.prototype.gameUuid = \"\";\n\n        /**\n         * BetCall betIndex.\n         * @member {number} betIndex\n         * @memberof bet.BetCall\n         * @instance\n         */\n        BetCall.prototype.betIndex = 0;\n\n        /**\n         * BetCall betArea.\n         * @member {bet.BetArea} betArea\n         * @memberof bet.BetCall\n         * @instance\n         */\n        BetCall.prototype.betArea = 0;\n\n        /**\n         * Creates a new BetCall instance using the specified properties.\n         * @function create\n         * @memberof bet.BetCall\n         * @static\n         * @param {bet.IBetCall=} [properties] Properties to set\n         * @returns {bet.BetCall} BetCall instance\n         */\n        BetCall.create = function create(properties) {\n            return new BetCall(properties);\n        };\n\n        /**\n         * Encodes the specified BetCall message. Does not implicitly {@link bet.BetCall.verify|verify} messages.\n         * @function encode\n         * @memberof bet.BetCall\n         * @static\n         * @param {bet.IBetCall} message BetCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetCall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.gameUuid != null && Object.hasOwnProperty.call(message, \"gameUuid\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gameUuid);\n            if (message.betIndex != null && Object.hasOwnProperty.call(message, \"betIndex\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.betIndex);\n            if (message.betArea != null && Object.hasOwnProperty.call(message, \"betArea\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.betArea);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BetCall message, length delimited. Does not implicitly {@link bet.BetCall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof bet.BetCall\n         * @static\n         * @param {bet.IBetCall} message BetCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetCall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BetCall message from the specified reader or buffer.\n         * @function decode\n         * @memberof bet.BetCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {bet.BetCall} BetCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetCall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.bet.BetCall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.gameUuid = reader.string();\n                    break;\n                case 3:\n                    message.betIndex = reader.int32();\n                    break;\n                case 4:\n                    message.betArea = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BetCall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof bet.BetCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {bet.BetCall} BetCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetCall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BetCall message.\n         * @function verify\n         * @memberof bet.BetCall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BetCall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.gameUuid != null && message.hasOwnProperty(\"gameUuid\"))\n                if (!$util.isString(message.gameUuid))\n                    return \"gameUuid: string expected\";\n            if (message.betIndex != null && message.hasOwnProperty(\"betIndex\"))\n                if (!$util.isInteger(message.betIndex))\n                    return \"betIndex: integer expected\";\n            if (message.betArea != null && message.hasOwnProperty(\"betArea\"))\n                switch (message.betArea) {\n                default:\n                    return \"betArea: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                    break;\n                }\n            return null;\n        };\n\n        /**\n         * Creates a BetCall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof bet.BetCall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {bet.BetCall} BetCall\n         */\n        BetCall.fromObject = function fromObject(object) {\n            if (object instanceof $root.bet.BetCall)\n                return object;\n            let message = new $root.bet.BetCall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".bet.BetCall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.gameUuid != null)\n                message.gameUuid = String(object.gameUuid);\n            if (object.betIndex != null)\n                message.betIndex = object.betIndex | 0;\n            switch (object.betArea) {\n            case \"BetAreaDefault\":\n            case 0:\n                message.betArea = 0;\n                break;\n            case \"Player\":\n            case 1:\n                message.betArea = 1;\n                break;\n            case \"Banker\":\n            case 2:\n                message.betArea = 2;\n                break;\n            case \"PlayerPair\":\n            case 3:\n                message.betArea = 3;\n                break;\n            case \"Tie\":\n            case 4:\n                message.betArea = 4;\n                break;\n            case \"BankerPair\":\n            case 5:\n                message.betArea = 5;\n                break;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BetCall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof bet.BetCall\n         * @static\n         * @param {bet.BetCall} message BetCall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BetCall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.gameUuid = \"\";\n                object.betIndex = 0;\n                object.betArea = options.enums === String ? \"BetAreaDefault\" : 0;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.gameUuid != null && message.hasOwnProperty(\"gameUuid\"))\n                object.gameUuid = message.gameUuid;\n            if (message.betIndex != null && message.hasOwnProperty(\"betIndex\"))\n                object.betIndex = message.betIndex;\n            if (message.betArea != null && message.hasOwnProperty(\"betArea\"))\n                object.betArea = options.enums === String ? $root.bet.BetArea[message.betArea] : message.betArea;\n            return object;\n        };\n\n        /**\n         * Converts this BetCall to JSON.\n         * @function toJSON\n         * @memberof bet.BetCall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BetCall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BetCall;\n    })();\n\n    bet.BetRecall = (function() {\n\n        /**\n         * Properties of a BetRecall.\n         * @memberof bet\n         * @interface IBetRecall\n         * @property {foundation.IHeader|null} [header] BetRecall header\n         * @property {number|null} [result] BetRecall result\n         * @property {number|null} [totalBets] BetRecall totalBets\n         * @property {bet.IBetStatus|null} [betStatus] BetRecall betStatus\n         * @property {bet.IBetError|null} [betError] BetRecall betError\n         */\n\n        /**\n         * Constructs a new BetRecall.\n         * @memberof bet\n         * @classdesc Represents a BetRecall.\n         * @implements IBetRecall\n         * @constructor\n         * @param {bet.IBetRecall=} [properties] Properties to set\n         */\n        function BetRecall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BetRecall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof bet.BetRecall\n         * @instance\n         */\n        BetRecall.prototype.header = null;\n\n        /**\n         * BetRecall result.\n         * @member {number} result\n         * @memberof bet.BetRecall\n         * @instance\n         */\n        BetRecall.prototype.result = 0;\n\n        /**\n         * BetRecall totalBets.\n         * @member {number} totalBets\n         * @memberof bet.BetRecall\n         * @instance\n         */\n        BetRecall.prototype.totalBets = 0;\n\n        /**\n         * BetRecall betStatus.\n         * @member {bet.IBetStatus|null|undefined} betStatus\n         * @memberof bet.BetRecall\n         * @instance\n         */\n        BetRecall.prototype.betStatus = null;\n\n        /**\n         * BetRecall betError.\n         * @member {bet.IBetError|null|undefined} betError\n         * @memberof bet.BetRecall\n         * @instance\n         */\n        BetRecall.prototype.betError = null;\n\n        /**\n         * Creates a new BetRecall instance using the specified properties.\n         * @function create\n         * @memberof bet.BetRecall\n         * @static\n         * @param {bet.IBetRecall=} [properties] Properties to set\n         * @returns {bet.BetRecall} BetRecall instance\n         */\n        BetRecall.create = function create(properties) {\n            return new BetRecall(properties);\n        };\n\n        /**\n         * Encodes the specified BetRecall message. Does not implicitly {@link bet.BetRecall.verify|verify} messages.\n         * @function encode\n         * @memberof bet.BetRecall\n         * @static\n         * @param {bet.IBetRecall} message BetRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetRecall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.result != null && Object.hasOwnProperty.call(message, \"result\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.result);\n            if (message.totalBets != null && Object.hasOwnProperty.call(message, \"totalBets\"))\n                writer.uint32(/* id 3, wireType 1 =*/25).double(message.totalBets);\n            if (message.betStatus != null && Object.hasOwnProperty.call(message, \"betStatus\"))\n                $root.bet.BetStatus.encode(message.betStatus, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            if (message.betError != null && Object.hasOwnProperty.call(message, \"betError\"))\n                $root.bet.BetError.encode(message.betError, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BetRecall message, length delimited. Does not implicitly {@link bet.BetRecall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof bet.BetRecall\n         * @static\n         * @param {bet.IBetRecall} message BetRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetRecall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BetRecall message from the specified reader or buffer.\n         * @function decode\n         * @memberof bet.BetRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {bet.BetRecall} BetRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetRecall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.bet.BetRecall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.result = reader.int32();\n                    break;\n                case 3:\n                    message.totalBets = reader.double();\n                    break;\n                case 4:\n                    message.betStatus = $root.bet.BetStatus.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.betError = $root.bet.BetError.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BetRecall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof bet.BetRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {bet.BetRecall} BetRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetRecall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BetRecall message.\n         * @function verify\n         * @memberof bet.BetRecall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BetRecall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                if (!$util.isInteger(message.result))\n                    return \"result: integer expected\";\n            if (message.totalBets != null && message.hasOwnProperty(\"totalBets\"))\n                if (typeof message.totalBets !== \"number\")\n                    return \"totalBets: number expected\";\n            if (message.betStatus != null && message.hasOwnProperty(\"betStatus\")) {\n                let error = $root.bet.BetStatus.verify(message.betStatus);\n                if (error)\n                    return \"betStatus.\" + error;\n            }\n            if (message.betError != null && message.hasOwnProperty(\"betError\")) {\n                let error = $root.bet.BetError.verify(message.betError);\n                if (error)\n                    return \"betError.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BetRecall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof bet.BetRecall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {bet.BetRecall} BetRecall\n         */\n        BetRecall.fromObject = function fromObject(object) {\n            if (object instanceof $root.bet.BetRecall)\n                return object;\n            let message = new $root.bet.BetRecall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".bet.BetRecall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.result != null)\n                message.result = object.result | 0;\n            if (object.totalBets != null)\n                message.totalBets = Number(object.totalBets);\n            if (object.betStatus != null) {\n                if (typeof object.betStatus !== \"object\")\n                    throw TypeError(\".bet.BetRecall.betStatus: object expected\");\n                message.betStatus = $root.bet.BetStatus.fromObject(object.betStatus);\n            }\n            if (object.betError != null) {\n                if (typeof object.betError !== \"object\")\n                    throw TypeError(\".bet.BetRecall.betError: object expected\");\n                message.betError = $root.bet.BetError.fromObject(object.betError);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BetRecall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof bet.BetRecall\n         * @static\n         * @param {bet.BetRecall} message BetRecall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BetRecall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.result = 0;\n                object.totalBets = 0;\n                object.betStatus = null;\n                object.betError = null;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                object.result = message.result;\n            if (message.totalBets != null && message.hasOwnProperty(\"totalBets\"))\n                object.totalBets = options.json && !isFinite(message.totalBets) ? String(message.totalBets) : message.totalBets;\n            if (message.betStatus != null && message.hasOwnProperty(\"betStatus\"))\n                object.betStatus = $root.bet.BetStatus.toObject(message.betStatus, options);\n            if (message.betError != null && message.hasOwnProperty(\"betError\"))\n                object.betError = $root.bet.BetError.toObject(message.betError, options);\n            return object;\n        };\n\n        /**\n         * Converts this BetRecall to JSON.\n         * @function toJSON\n         * @memberof bet.BetRecall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BetRecall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BetRecall;\n    })();\n\n    bet.BetResetCall = (function() {\n\n        /**\n         * Properties of a BetResetCall.\n         * @memberof bet\n         * @interface IBetResetCall\n         * @property {foundation.IHeader|null} [header] BetResetCall header\n         * @property {string|null} [gameUuid] BetResetCall gameUuid\n         */\n\n        /**\n         * Constructs a new BetResetCall.\n         * @memberof bet\n         * @classdesc Represents a BetResetCall.\n         * @implements IBetResetCall\n         * @constructor\n         * @param {bet.IBetResetCall=} [properties] Properties to set\n         */\n        function BetResetCall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BetResetCall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof bet.BetResetCall\n         * @instance\n         */\n        BetResetCall.prototype.header = null;\n\n        /**\n         * BetResetCall gameUuid.\n         * @member {string} gameUuid\n         * @memberof bet.BetResetCall\n         * @instance\n         */\n        BetResetCall.prototype.gameUuid = \"\";\n\n        /**\n         * Creates a new BetResetCall instance using the specified properties.\n         * @function create\n         * @memberof bet.BetResetCall\n         * @static\n         * @param {bet.IBetResetCall=} [properties] Properties to set\n         * @returns {bet.BetResetCall} BetResetCall instance\n         */\n        BetResetCall.create = function create(properties) {\n            return new BetResetCall(properties);\n        };\n\n        /**\n         * Encodes the specified BetResetCall message. Does not implicitly {@link bet.BetResetCall.verify|verify} messages.\n         * @function encode\n         * @memberof bet.BetResetCall\n         * @static\n         * @param {bet.IBetResetCall} message BetResetCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetResetCall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.gameUuid != null && Object.hasOwnProperty.call(message, \"gameUuid\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gameUuid);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BetResetCall message, length delimited. Does not implicitly {@link bet.BetResetCall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof bet.BetResetCall\n         * @static\n         * @param {bet.IBetResetCall} message BetResetCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetResetCall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BetResetCall message from the specified reader or buffer.\n         * @function decode\n         * @memberof bet.BetResetCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {bet.BetResetCall} BetResetCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetResetCall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.bet.BetResetCall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.gameUuid = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BetResetCall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof bet.BetResetCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {bet.BetResetCall} BetResetCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetResetCall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BetResetCall message.\n         * @function verify\n         * @memberof bet.BetResetCall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BetResetCall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.gameUuid != null && message.hasOwnProperty(\"gameUuid\"))\n                if (!$util.isString(message.gameUuid))\n                    return \"gameUuid: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a BetResetCall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof bet.BetResetCall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {bet.BetResetCall} BetResetCall\n         */\n        BetResetCall.fromObject = function fromObject(object) {\n            if (object instanceof $root.bet.BetResetCall)\n                return object;\n            let message = new $root.bet.BetResetCall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".bet.BetResetCall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.gameUuid != null)\n                message.gameUuid = String(object.gameUuid);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BetResetCall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof bet.BetResetCall\n         * @static\n         * @param {bet.BetResetCall} message BetResetCall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BetResetCall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.gameUuid = \"\";\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.gameUuid != null && message.hasOwnProperty(\"gameUuid\"))\n                object.gameUuid = message.gameUuid;\n            return object;\n        };\n\n        /**\n         * Converts this BetResetCall to JSON.\n         * @function toJSON\n         * @memberof bet.BetResetCall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BetResetCall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BetResetCall;\n    })();\n\n    bet.BetResetRecall = (function() {\n\n        /**\n         * Properties of a BetResetRecall.\n         * @memberof bet\n         * @interface IBetResetRecall\n         * @property {foundation.IHeader|null} [header] BetResetRecall header\n         * @property {number|null} [result] BetResetRecall result\n         * @property {number|null} [totalBets] BetResetRecall totalBets\n         * @property {bet.IBetStatus|null} [betStatus] BetResetRecall betStatus\n         */\n\n        /**\n         * Constructs a new BetResetRecall.\n         * @memberof bet\n         * @classdesc Represents a BetResetRecall.\n         * @implements IBetResetRecall\n         * @constructor\n         * @param {bet.IBetResetRecall=} [properties] Properties to set\n         */\n        function BetResetRecall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BetResetRecall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof bet.BetResetRecall\n         * @instance\n         */\n        BetResetRecall.prototype.header = null;\n\n        /**\n         * BetResetRecall result.\n         * @member {number} result\n         * @memberof bet.BetResetRecall\n         * @instance\n         */\n        BetResetRecall.prototype.result = 0;\n\n        /**\n         * BetResetRecall totalBets.\n         * @member {number} totalBets\n         * @memberof bet.BetResetRecall\n         * @instance\n         */\n        BetResetRecall.prototype.totalBets = 0;\n\n        /**\n         * BetResetRecall betStatus.\n         * @member {bet.IBetStatus|null|undefined} betStatus\n         * @memberof bet.BetResetRecall\n         * @instance\n         */\n        BetResetRecall.prototype.betStatus = null;\n\n        /**\n         * Creates a new BetResetRecall instance using the specified properties.\n         * @function create\n         * @memberof bet.BetResetRecall\n         * @static\n         * @param {bet.IBetResetRecall=} [properties] Properties to set\n         * @returns {bet.BetResetRecall} BetResetRecall instance\n         */\n        BetResetRecall.create = function create(properties) {\n            return new BetResetRecall(properties);\n        };\n\n        /**\n         * Encodes the specified BetResetRecall message. Does not implicitly {@link bet.BetResetRecall.verify|verify} messages.\n         * @function encode\n         * @memberof bet.BetResetRecall\n         * @static\n         * @param {bet.IBetResetRecall} message BetResetRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetResetRecall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.result != null && Object.hasOwnProperty.call(message, \"result\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.result);\n            if (message.totalBets != null && Object.hasOwnProperty.call(message, \"totalBets\"))\n                writer.uint32(/* id 3, wireType 1 =*/25).double(message.totalBets);\n            if (message.betStatus != null && Object.hasOwnProperty.call(message, \"betStatus\"))\n                $root.bet.BetStatus.encode(message.betStatus, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BetResetRecall message, length delimited. Does not implicitly {@link bet.BetResetRecall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof bet.BetResetRecall\n         * @static\n         * @param {bet.IBetResetRecall} message BetResetRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetResetRecall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BetResetRecall message from the specified reader or buffer.\n         * @function decode\n         * @memberof bet.BetResetRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {bet.BetResetRecall} BetResetRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetResetRecall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.bet.BetResetRecall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.result = reader.int32();\n                    break;\n                case 3:\n                    message.totalBets = reader.double();\n                    break;\n                case 4:\n                    message.betStatus = $root.bet.BetStatus.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BetResetRecall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof bet.BetResetRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {bet.BetResetRecall} BetResetRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetResetRecall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BetResetRecall message.\n         * @function verify\n         * @memberof bet.BetResetRecall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BetResetRecall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                if (!$util.isInteger(message.result))\n                    return \"result: integer expected\";\n            if (message.totalBets != null && message.hasOwnProperty(\"totalBets\"))\n                if (typeof message.totalBets !== \"number\")\n                    return \"totalBets: number expected\";\n            if (message.betStatus != null && message.hasOwnProperty(\"betStatus\")) {\n                let error = $root.bet.BetStatus.verify(message.betStatus);\n                if (error)\n                    return \"betStatus.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BetResetRecall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof bet.BetResetRecall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {bet.BetResetRecall} BetResetRecall\n         */\n        BetResetRecall.fromObject = function fromObject(object) {\n            if (object instanceof $root.bet.BetResetRecall)\n                return object;\n            let message = new $root.bet.BetResetRecall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".bet.BetResetRecall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.result != null)\n                message.result = object.result | 0;\n            if (object.totalBets != null)\n                message.totalBets = Number(object.totalBets);\n            if (object.betStatus != null) {\n                if (typeof object.betStatus !== \"object\")\n                    throw TypeError(\".bet.BetResetRecall.betStatus: object expected\");\n                message.betStatus = $root.bet.BetStatus.fromObject(object.betStatus);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BetResetRecall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof bet.BetResetRecall\n         * @static\n         * @param {bet.BetResetRecall} message BetResetRecall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BetResetRecall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.result = 0;\n                object.totalBets = 0;\n                object.betStatus = null;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                object.result = message.result;\n            if (message.totalBets != null && message.hasOwnProperty(\"totalBets\"))\n                object.totalBets = options.json && !isFinite(message.totalBets) ? String(message.totalBets) : message.totalBets;\n            if (message.betStatus != null && message.hasOwnProperty(\"betStatus\"))\n                object.betStatus = $root.bet.BetStatus.toObject(message.betStatus, options);\n            return object;\n        };\n\n        /**\n         * Converts this BetResetRecall to JSON.\n         * @function toJSON\n         * @memberof bet.BetResetRecall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BetResetRecall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BetResetRecall;\n    })();\n\n    bet.BetError = (function() {\n\n        /**\n         * Properties of a BetError.\n         * @memberof bet\n         * @interface IBetError\n         * @property {foundation.IHeader|null} [header] BetError header\n         * @property {bet.Error|null} [error] BetError error\n         * @property {string|null} [errorMessage] BetError errorMessage\n         */\n\n        /**\n         * Constructs a new BetError.\n         * @memberof bet\n         * @classdesc Represents a BetError.\n         * @implements IBetError\n         * @constructor\n         * @param {bet.IBetError=} [properties] Properties to set\n         */\n        function BetError(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BetError header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof bet.BetError\n         * @instance\n         */\n        BetError.prototype.header = null;\n\n        /**\n         * BetError error.\n         * @member {bet.Error} error\n         * @memberof bet.BetError\n         * @instance\n         */\n        BetError.prototype.error = 0;\n\n        /**\n         * BetError errorMessage.\n         * @member {string} errorMessage\n         * @memberof bet.BetError\n         * @instance\n         */\n        BetError.prototype.errorMessage = \"\";\n\n        /**\n         * Creates a new BetError instance using the specified properties.\n         * @function create\n         * @memberof bet.BetError\n         * @static\n         * @param {bet.IBetError=} [properties] Properties to set\n         * @returns {bet.BetError} BetError instance\n         */\n        BetError.create = function create(properties) {\n            return new BetError(properties);\n        };\n\n        /**\n         * Encodes the specified BetError message. Does not implicitly {@link bet.BetError.verify|verify} messages.\n         * @function encode\n         * @memberof bet.BetError\n         * @static\n         * @param {bet.IBetError} message BetError message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetError.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.error != null && Object.hasOwnProperty.call(message, \"error\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.error);\n            if (message.errorMessage != null && Object.hasOwnProperty.call(message, \"errorMessage\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.errorMessage);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BetError message, length delimited. Does not implicitly {@link bet.BetError.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof bet.BetError\n         * @static\n         * @param {bet.IBetError} message BetError message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetError.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BetError message from the specified reader or buffer.\n         * @function decode\n         * @memberof bet.BetError\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {bet.BetError} BetError\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetError.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.bet.BetError();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.error = reader.int32();\n                    break;\n                case 3:\n                    message.errorMessage = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BetError message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof bet.BetError\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {bet.BetError} BetError\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetError.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BetError message.\n         * @function verify\n         * @memberof bet.BetError\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BetError.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.error != null && message.hasOwnProperty(\"error\"))\n                switch (message.error) {\n                default:\n                    return \"error: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                if (!$util.isString(message.errorMessage))\n                    return \"errorMessage: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a BetError message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof bet.BetError\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {bet.BetError} BetError\n         */\n        BetError.fromObject = function fromObject(object) {\n            if (object instanceof $root.bet.BetError)\n                return object;\n            let message = new $root.bet.BetError();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".bet.BetError.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            switch (object.error) {\n            case \"ErrorDefault\":\n            case 0:\n                message.error = 0;\n                break;\n            case \"BetTimeNotInvlid\":\n            case 1:\n                message.error = 1;\n                break;\n            case \"BetIndexInvalid\":\n            case 2:\n                message.error = 2;\n                break;\n            case \"BetAreaInvalid\":\n            case 3:\n                message.error = 3;\n                break;\n            case \"ReachMaxLimit\":\n            case 4:\n                message.error = 4;\n                break;\n            case \"RoundNotFound\":\n            case 5:\n                message.error = 5;\n                break;\n            case \"NoEnoughWallet\":\n            case 6:\n                message.error = 6;\n                break;\n            }\n            if (object.errorMessage != null)\n                message.errorMessage = String(object.errorMessage);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BetError message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof bet.BetError\n         * @static\n         * @param {bet.BetError} message BetError\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BetError.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.error = options.enums === String ? \"ErrorDefault\" : 0;\n                object.errorMessage = \"\";\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.error != null && message.hasOwnProperty(\"error\"))\n                object.error = options.enums === String ? $root.bet.Error[message.error] : message.error;\n            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                object.errorMessage = message.errorMessage;\n            return object;\n        };\n\n        /**\n         * Converts this BetError to JSON.\n         * @function toJSON\n         * @memberof bet.BetError\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BetError.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BetError;\n    })();\n\n    return bet;\n})();\n\nexport const dealer = $root.dealer = (() => {\n\n    /**\n     * Namespace dealer.\n     * @exports dealer\n     * @namespace\n     */\n    const dealer = {};\n\n    /**\n     * Suit enum.\n     * @name dealer.Suit\n     * @enum {number}\n     * @property {number} Default=0 Default value\n     * @property {number} Heart=1 Heart value\n     * @property {number} Diamond=2 Diamond value\n     * @property {number} Spade=3 Spade value\n     * @property {number} Club=4 Club value\n     */\n    dealer.Suit = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Default\"] = 0;\n        values[valuesById[1] = \"Heart\"] = 1;\n        values[valuesById[2] = \"Diamond\"] = 2;\n        values[valuesById[3] = \"Spade\"] = 3;\n        values[valuesById[4] = \"Club\"] = 4;\n        return values;\n    })();\n\n    dealer.Card = (function() {\n\n        /**\n         * Properties of a Card.\n         * @memberof dealer\n         * @interface ICard\n         * @property {dealer.Suit|null} [suit] Card suit\n         * @property {number|null} [point] Card point\n         */\n\n        /**\n         * Constructs a new Card.\n         * @memberof dealer\n         * @classdesc Represents a Card.\n         * @implements ICard\n         * @constructor\n         * @param {dealer.ICard=} [properties] Properties to set\n         */\n        function Card(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Card suit.\n         * @member {dealer.Suit} suit\n         * @memberof dealer.Card\n         * @instance\n         */\n        Card.prototype.suit = 0;\n\n        /**\n         * Card point.\n         * @member {number} point\n         * @memberof dealer.Card\n         * @instance\n         */\n        Card.prototype.point = 0;\n\n        /**\n         * Creates a new Card instance using the specified properties.\n         * @function create\n         * @memberof dealer.Card\n         * @static\n         * @param {dealer.ICard=} [properties] Properties to set\n         * @returns {dealer.Card} Card instance\n         */\n        Card.create = function create(properties) {\n            return new Card(properties);\n        };\n\n        /**\n         * Encodes the specified Card message. Does not implicitly {@link dealer.Card.verify|verify} messages.\n         * @function encode\n         * @memberof dealer.Card\n         * @static\n         * @param {dealer.ICard} message Card message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Card.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.suit != null && Object.hasOwnProperty.call(message, \"suit\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.suit);\n            if (message.point != null && Object.hasOwnProperty.call(message, \"point\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.point);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Card message, length delimited. Does not implicitly {@link dealer.Card.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof dealer.Card\n         * @static\n         * @param {dealer.ICard} message Card message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Card.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Card message from the specified reader or buffer.\n         * @function decode\n         * @memberof dealer.Card\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {dealer.Card} Card\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Card.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dealer.Card();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.suit = reader.int32();\n                    break;\n                case 2:\n                    message.point = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Card message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof dealer.Card\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {dealer.Card} Card\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Card.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Card message.\n         * @function verify\n         * @memberof dealer.Card\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Card.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.suit != null && message.hasOwnProperty(\"suit\"))\n                switch (message.suit) {\n                default:\n                    return \"suit: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                    break;\n                }\n            if (message.point != null && message.hasOwnProperty(\"point\"))\n                if (!$util.isInteger(message.point))\n                    return \"point: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a Card message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof dealer.Card\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {dealer.Card} Card\n         */\n        Card.fromObject = function fromObject(object) {\n            if (object instanceof $root.dealer.Card)\n                return object;\n            let message = new $root.dealer.Card();\n            switch (object.suit) {\n            case \"Default\":\n            case 0:\n                message.suit = 0;\n                break;\n            case \"Heart\":\n            case 1:\n                message.suit = 1;\n                break;\n            case \"Diamond\":\n            case 2:\n                message.suit = 2;\n                break;\n            case \"Spade\":\n            case 3:\n                message.suit = 3;\n                break;\n            case \"Club\":\n            case 4:\n                message.suit = 4;\n                break;\n            }\n            if (object.point != null)\n                message.point = object.point | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Card message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof dealer.Card\n         * @static\n         * @param {dealer.Card} message Card\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Card.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.suit = options.enums === String ? \"Default\" : 0;\n                object.point = 0;\n            }\n            if (message.suit != null && message.hasOwnProperty(\"suit\"))\n                object.suit = options.enums === String ? $root.dealer.Suit[message.suit] : message.suit;\n            if (message.point != null && message.hasOwnProperty(\"point\"))\n                object.point = message.point;\n            return object;\n        };\n\n        /**\n         * Converts this Card to JSON.\n         * @function toJSON\n         * @memberof dealer.Card\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Card.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Card;\n    })();\n\n    /**\n     * Side enum.\n     * @name dealer.Side\n     * @enum {number}\n     * @property {number} SideDefault=0 SideDefault value\n     * @property {number} Banker=1 Banker value\n     * @property {number} Player=2 Player value\n     */\n    dealer.Side = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"SideDefault\"] = 0;\n        values[valuesById[1] = \"Banker\"] = 1;\n        values[valuesById[2] = \"Player\"] = 2;\n        return values;\n    })();\n\n    dealer.Draw = (function() {\n\n        /**\n         * Properties of a Draw.\n         * @memberof dealer\n         * @interface IDraw\n         * @property {foundation.IHeader|null} [header] Draw header\n         * @property {dealer.Side|null} [side] Draw side\n         * @property {number|null} [position] Draw position\n         * @property {dealer.ICard|null} [card] Draw card\n         */\n\n        /**\n         * Constructs a new Draw.\n         * @memberof dealer\n         * @classdesc Represents a Draw.\n         * @implements IDraw\n         * @constructor\n         * @param {dealer.IDraw=} [properties] Properties to set\n         */\n        function Draw(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Draw header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof dealer.Draw\n         * @instance\n         */\n        Draw.prototype.header = null;\n\n        /**\n         * Draw side.\n         * @member {dealer.Side} side\n         * @memberof dealer.Draw\n         * @instance\n         */\n        Draw.prototype.side = 0;\n\n        /**\n         * Draw position.\n         * @member {number} position\n         * @memberof dealer.Draw\n         * @instance\n         */\n        Draw.prototype.position = 0;\n\n        /**\n         * Draw card.\n         * @member {dealer.ICard|null|undefined} card\n         * @memberof dealer.Draw\n         * @instance\n         */\n        Draw.prototype.card = null;\n\n        /**\n         * Creates a new Draw instance using the specified properties.\n         * @function create\n         * @memberof dealer.Draw\n         * @static\n         * @param {dealer.IDraw=} [properties] Properties to set\n         * @returns {dealer.Draw} Draw instance\n         */\n        Draw.create = function create(properties) {\n            return new Draw(properties);\n        };\n\n        /**\n         * Encodes the specified Draw message. Does not implicitly {@link dealer.Draw.verify|verify} messages.\n         * @function encode\n         * @memberof dealer.Draw\n         * @static\n         * @param {dealer.IDraw} message Draw message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Draw.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.side != null && Object.hasOwnProperty.call(message, \"side\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.side);\n            if (message.position != null && Object.hasOwnProperty.call(message, \"position\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.position);\n            if (message.card != null && Object.hasOwnProperty.call(message, \"card\"))\n                $root.dealer.Card.encode(message.card, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Draw message, length delimited. Does not implicitly {@link dealer.Draw.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof dealer.Draw\n         * @static\n         * @param {dealer.IDraw} message Draw message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Draw.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Draw message from the specified reader or buffer.\n         * @function decode\n         * @memberof dealer.Draw\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {dealer.Draw} Draw\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Draw.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dealer.Draw();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.side = reader.int32();\n                    break;\n                case 3:\n                    message.position = reader.int32();\n                    break;\n                case 4:\n                    message.card = $root.dealer.Card.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Draw message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof dealer.Draw\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {dealer.Draw} Draw\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Draw.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Draw message.\n         * @function verify\n         * @memberof dealer.Draw\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Draw.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.side != null && message.hasOwnProperty(\"side\"))\n                switch (message.side) {\n                default:\n                    return \"side: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                    break;\n                }\n            if (message.position != null && message.hasOwnProperty(\"position\"))\n                if (!$util.isInteger(message.position))\n                    return \"position: integer expected\";\n            if (message.card != null && message.hasOwnProperty(\"card\")) {\n                let error = $root.dealer.Card.verify(message.card);\n                if (error)\n                    return \"card.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a Draw message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof dealer.Draw\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {dealer.Draw} Draw\n         */\n        Draw.fromObject = function fromObject(object) {\n            if (object instanceof $root.dealer.Draw)\n                return object;\n            let message = new $root.dealer.Draw();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".dealer.Draw.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            switch (object.side) {\n            case \"SideDefault\":\n            case 0:\n                message.side = 0;\n                break;\n            case \"Banker\":\n            case 1:\n                message.side = 1;\n                break;\n            case \"Player\":\n            case 2:\n                message.side = 2;\n                break;\n            }\n            if (object.position != null)\n                message.position = object.position | 0;\n            if (object.card != null) {\n                if (typeof object.card !== \"object\")\n                    throw TypeError(\".dealer.Draw.card: object expected\");\n                message.card = $root.dealer.Card.fromObject(object.card);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Draw message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof dealer.Draw\n         * @static\n         * @param {dealer.Draw} message Draw\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Draw.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.side = options.enums === String ? \"SideDefault\" : 0;\n                object.position = 0;\n                object.card = null;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.side != null && message.hasOwnProperty(\"side\"))\n                object.side = options.enums === String ? $root.dealer.Side[message.side] : message.side;\n            if (message.position != null && message.hasOwnProperty(\"position\"))\n                object.position = message.position;\n            if (message.card != null && message.hasOwnProperty(\"card\"))\n                object.card = $root.dealer.Card.toObject(message.card, options);\n            return object;\n        };\n\n        /**\n         * Converts this Draw to JSON.\n         * @function toJSON\n         * @memberof dealer.Draw\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Draw.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Draw;\n    })();\n\n    dealer.RoundStartCall = (function() {\n\n        /**\n         * Properties of a RoundStartCall.\n         * @memberof dealer\n         * @interface IRoundStartCall\n         * @property {foundation.IHeader|null} [header] RoundStartCall header\n         */\n\n        /**\n         * Constructs a new RoundStartCall.\n         * @memberof dealer\n         * @classdesc Represents a RoundStartCall.\n         * @implements IRoundStartCall\n         * @constructor\n         * @param {dealer.IRoundStartCall=} [properties] Properties to set\n         */\n        function RoundStartCall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * RoundStartCall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof dealer.RoundStartCall\n         * @instance\n         */\n        RoundStartCall.prototype.header = null;\n\n        /**\n         * Creates a new RoundStartCall instance using the specified properties.\n         * @function create\n         * @memberof dealer.RoundStartCall\n         * @static\n         * @param {dealer.IRoundStartCall=} [properties] Properties to set\n         * @returns {dealer.RoundStartCall} RoundStartCall instance\n         */\n        RoundStartCall.create = function create(properties) {\n            return new RoundStartCall(properties);\n        };\n\n        /**\n         * Encodes the specified RoundStartCall message. Does not implicitly {@link dealer.RoundStartCall.verify|verify} messages.\n         * @function encode\n         * @memberof dealer.RoundStartCall\n         * @static\n         * @param {dealer.IRoundStartCall} message RoundStartCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        RoundStartCall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified RoundStartCall message, length delimited. Does not implicitly {@link dealer.RoundStartCall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof dealer.RoundStartCall\n         * @static\n         * @param {dealer.IRoundStartCall} message RoundStartCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        RoundStartCall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a RoundStartCall message from the specified reader or buffer.\n         * @function decode\n         * @memberof dealer.RoundStartCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {dealer.RoundStartCall} RoundStartCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RoundStartCall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dealer.RoundStartCall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a RoundStartCall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof dealer.RoundStartCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {dealer.RoundStartCall} RoundStartCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RoundStartCall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a RoundStartCall message.\n         * @function verify\n         * @memberof dealer.RoundStartCall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        RoundStartCall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a RoundStartCall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof dealer.RoundStartCall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {dealer.RoundStartCall} RoundStartCall\n         */\n        RoundStartCall.fromObject = function fromObject(object) {\n            if (object instanceof $root.dealer.RoundStartCall)\n                return object;\n            let message = new $root.dealer.RoundStartCall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".dealer.RoundStartCall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a RoundStartCall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof dealer.RoundStartCall\n         * @static\n         * @param {dealer.RoundStartCall} message RoundStartCall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        RoundStartCall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults)\n                object.header = null;\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            return object;\n        };\n\n        /**\n         * Converts this RoundStartCall to JSON.\n         * @function toJSON\n         * @memberof dealer.RoundStartCall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        RoundStartCall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RoundStartCall;\n    })();\n\n    dealer.RoundEndCall = (function() {\n\n        /**\n         * Properties of a RoundEndCall.\n         * @memberof dealer\n         * @interface IRoundEndCall\n         * @property {foundation.IHeader|null} [header] RoundEndCall header\n         */\n\n        /**\n         * Constructs a new RoundEndCall.\n         * @memberof dealer\n         * @classdesc Represents a RoundEndCall.\n         * @implements IRoundEndCall\n         * @constructor\n         * @param {dealer.IRoundEndCall=} [properties] Properties to set\n         */\n        function RoundEndCall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * RoundEndCall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof dealer.RoundEndCall\n         * @instance\n         */\n        RoundEndCall.prototype.header = null;\n\n        /**\n         * Creates a new RoundEndCall instance using the specified properties.\n         * @function create\n         * @memberof dealer.RoundEndCall\n         * @static\n         * @param {dealer.IRoundEndCall=} [properties] Properties to set\n         * @returns {dealer.RoundEndCall} RoundEndCall instance\n         */\n        RoundEndCall.create = function create(properties) {\n            return new RoundEndCall(properties);\n        };\n\n        /**\n         * Encodes the specified RoundEndCall message. Does not implicitly {@link dealer.RoundEndCall.verify|verify} messages.\n         * @function encode\n         * @memberof dealer.RoundEndCall\n         * @static\n         * @param {dealer.IRoundEndCall} message RoundEndCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        RoundEndCall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified RoundEndCall message, length delimited. Does not implicitly {@link dealer.RoundEndCall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof dealer.RoundEndCall\n         * @static\n         * @param {dealer.IRoundEndCall} message RoundEndCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        RoundEndCall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a RoundEndCall message from the specified reader or buffer.\n         * @function decode\n         * @memberof dealer.RoundEndCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {dealer.RoundEndCall} RoundEndCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RoundEndCall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dealer.RoundEndCall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a RoundEndCall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof dealer.RoundEndCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {dealer.RoundEndCall} RoundEndCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RoundEndCall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a RoundEndCall message.\n         * @function verify\n         * @memberof dealer.RoundEndCall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        RoundEndCall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a RoundEndCall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof dealer.RoundEndCall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {dealer.RoundEndCall} RoundEndCall\n         */\n        RoundEndCall.fromObject = function fromObject(object) {\n            if (object instanceof $root.dealer.RoundEndCall)\n                return object;\n            let message = new $root.dealer.RoundEndCall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".dealer.RoundEndCall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a RoundEndCall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof dealer.RoundEndCall\n         * @static\n         * @param {dealer.RoundEndCall} message RoundEndCall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        RoundEndCall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults)\n                object.header = null;\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            return object;\n        };\n\n        /**\n         * Converts this RoundEndCall to JSON.\n         * @function toJSON\n         * @memberof dealer.RoundEndCall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        RoundEndCall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RoundEndCall;\n    })();\n\n    dealer.RoundStartRecall = (function() {\n\n        /**\n         * Properties of a RoundStartRecall.\n         * @memberof dealer\n         * @interface IRoundStartRecall\n         * @property {foundation.IHeader|null} [header] RoundStartRecall header\n         * @property {number|null} [status] RoundStartRecall status\n         * @property {string|null} [message] RoundStartRecall message\n         */\n\n        /**\n         * Constructs a new RoundStartRecall.\n         * @memberof dealer\n         * @classdesc Represents a RoundStartRecall.\n         * @implements IRoundStartRecall\n         * @constructor\n         * @param {dealer.IRoundStartRecall=} [properties] Properties to set\n         */\n        function RoundStartRecall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * RoundStartRecall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof dealer.RoundStartRecall\n         * @instance\n         */\n        RoundStartRecall.prototype.header = null;\n\n        /**\n         * RoundStartRecall status.\n         * @member {number} status\n         * @memberof dealer.RoundStartRecall\n         * @instance\n         */\n        RoundStartRecall.prototype.status = 0;\n\n        /**\n         * RoundStartRecall message.\n         * @member {string} message\n         * @memberof dealer.RoundStartRecall\n         * @instance\n         */\n        RoundStartRecall.prototype.message = \"\";\n\n        /**\n         * Creates a new RoundStartRecall instance using the specified properties.\n         * @function create\n         * @memberof dealer.RoundStartRecall\n         * @static\n         * @param {dealer.IRoundStartRecall=} [properties] Properties to set\n         * @returns {dealer.RoundStartRecall} RoundStartRecall instance\n         */\n        RoundStartRecall.create = function create(properties) {\n            return new RoundStartRecall(properties);\n        };\n\n        /**\n         * Encodes the specified RoundStartRecall message. Does not implicitly {@link dealer.RoundStartRecall.verify|verify} messages.\n         * @function encode\n         * @memberof dealer.RoundStartRecall\n         * @static\n         * @param {dealer.IRoundStartRecall} message RoundStartRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        RoundStartRecall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.status != null && Object.hasOwnProperty.call(message, \"status\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);\n            if (message.message != null && Object.hasOwnProperty.call(message, \"message\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified RoundStartRecall message, length delimited. Does not implicitly {@link dealer.RoundStartRecall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof dealer.RoundStartRecall\n         * @static\n         * @param {dealer.IRoundStartRecall} message RoundStartRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        RoundStartRecall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a RoundStartRecall message from the specified reader or buffer.\n         * @function decode\n         * @memberof dealer.RoundStartRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {dealer.RoundStartRecall} RoundStartRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RoundStartRecall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dealer.RoundStartRecall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.status = reader.int32();\n                    break;\n                case 3:\n                    message.message = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a RoundStartRecall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof dealer.RoundStartRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {dealer.RoundStartRecall} RoundStartRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RoundStartRecall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a RoundStartRecall message.\n         * @function verify\n         * @memberof dealer.RoundStartRecall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        RoundStartRecall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.status != null && message.hasOwnProperty(\"status\"))\n                if (!$util.isInteger(message.status))\n                    return \"status: integer expected\";\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                if (!$util.isString(message.message))\n                    return \"message: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a RoundStartRecall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof dealer.RoundStartRecall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {dealer.RoundStartRecall} RoundStartRecall\n         */\n        RoundStartRecall.fromObject = function fromObject(object) {\n            if (object instanceof $root.dealer.RoundStartRecall)\n                return object;\n            let message = new $root.dealer.RoundStartRecall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".dealer.RoundStartRecall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.status != null)\n                message.status = object.status | 0;\n            if (object.message != null)\n                message.message = String(object.message);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a RoundStartRecall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof dealer.RoundStartRecall\n         * @static\n         * @param {dealer.RoundStartRecall} message RoundStartRecall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        RoundStartRecall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.status = 0;\n                object.message = \"\";\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.status != null && message.hasOwnProperty(\"status\"))\n                object.status = message.status;\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                object.message = message.message;\n            return object;\n        };\n\n        /**\n         * Converts this RoundStartRecall to JSON.\n         * @function toJSON\n         * @memberof dealer.RoundStartRecall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        RoundStartRecall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RoundStartRecall;\n    })();\n\n    dealer.RoundEndRecall = (function() {\n\n        /**\n         * Properties of a RoundEndRecall.\n         * @memberof dealer\n         * @interface IRoundEndRecall\n         * @property {foundation.IHeader|null} [header] RoundEndRecall header\n         * @property {number|null} [status] RoundEndRecall status\n         * @property {string|null} [message] RoundEndRecall message\n         */\n\n        /**\n         * Constructs a new RoundEndRecall.\n         * @memberof dealer\n         * @classdesc Represents a RoundEndRecall.\n         * @implements IRoundEndRecall\n         * @constructor\n         * @param {dealer.IRoundEndRecall=} [properties] Properties to set\n         */\n        function RoundEndRecall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * RoundEndRecall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof dealer.RoundEndRecall\n         * @instance\n         */\n        RoundEndRecall.prototype.header = null;\n\n        /**\n         * RoundEndRecall status.\n         * @member {number} status\n         * @memberof dealer.RoundEndRecall\n         * @instance\n         */\n        RoundEndRecall.prototype.status = 0;\n\n        /**\n         * RoundEndRecall message.\n         * @member {string} message\n         * @memberof dealer.RoundEndRecall\n         * @instance\n         */\n        RoundEndRecall.prototype.message = \"\";\n\n        /**\n         * Creates a new RoundEndRecall instance using the specified properties.\n         * @function create\n         * @memberof dealer.RoundEndRecall\n         * @static\n         * @param {dealer.IRoundEndRecall=} [properties] Properties to set\n         * @returns {dealer.RoundEndRecall} RoundEndRecall instance\n         */\n        RoundEndRecall.create = function create(properties) {\n            return new RoundEndRecall(properties);\n        };\n\n        /**\n         * Encodes the specified RoundEndRecall message. Does not implicitly {@link dealer.RoundEndRecall.verify|verify} messages.\n         * @function encode\n         * @memberof dealer.RoundEndRecall\n         * @static\n         * @param {dealer.IRoundEndRecall} message RoundEndRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        RoundEndRecall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.status != null && Object.hasOwnProperty.call(message, \"status\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);\n            if (message.message != null && Object.hasOwnProperty.call(message, \"message\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified RoundEndRecall message, length delimited. Does not implicitly {@link dealer.RoundEndRecall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof dealer.RoundEndRecall\n         * @static\n         * @param {dealer.IRoundEndRecall} message RoundEndRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        RoundEndRecall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a RoundEndRecall message from the specified reader or buffer.\n         * @function decode\n         * @memberof dealer.RoundEndRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {dealer.RoundEndRecall} RoundEndRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RoundEndRecall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dealer.RoundEndRecall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.status = reader.int32();\n                    break;\n                case 3:\n                    message.message = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a RoundEndRecall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof dealer.RoundEndRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {dealer.RoundEndRecall} RoundEndRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RoundEndRecall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a RoundEndRecall message.\n         * @function verify\n         * @memberof dealer.RoundEndRecall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        RoundEndRecall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.status != null && message.hasOwnProperty(\"status\"))\n                if (!$util.isInteger(message.status))\n                    return \"status: integer expected\";\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                if (!$util.isString(message.message))\n                    return \"message: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a RoundEndRecall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof dealer.RoundEndRecall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {dealer.RoundEndRecall} RoundEndRecall\n         */\n        RoundEndRecall.fromObject = function fromObject(object) {\n            if (object instanceof $root.dealer.RoundEndRecall)\n                return object;\n            let message = new $root.dealer.RoundEndRecall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".dealer.RoundEndRecall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.status != null)\n                message.status = object.status | 0;\n            if (object.message != null)\n                message.message = String(object.message);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a RoundEndRecall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof dealer.RoundEndRecall\n         * @static\n         * @param {dealer.RoundEndRecall} message RoundEndRecall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        RoundEndRecall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.status = 0;\n                object.message = \"\";\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.status != null && message.hasOwnProperty(\"status\"))\n                object.status = message.status;\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                object.message = message.message;\n            return object;\n        };\n\n        /**\n         * Converts this RoundEndRecall to JSON.\n         * @function toJSON\n         * @memberof dealer.RoundEndRecall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        RoundEndRecall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RoundEndRecall;\n    })();\n\n    dealer.BroadcastDealerRoundEnd = (function() {\n\n        /**\n         * Properties of a BroadcastDealerRoundEnd.\n         * @memberof dealer\n         * @interface IBroadcastDealerRoundEnd\n         * @property {foundation.IHeader|null} [header] BroadcastDealerRoundEnd header\n         */\n\n        /**\n         * Constructs a new BroadcastDealerRoundEnd.\n         * @memberof dealer\n         * @classdesc Represents a BroadcastDealerRoundEnd.\n         * @implements IBroadcastDealerRoundEnd\n         * @constructor\n         * @param {dealer.IBroadcastDealerRoundEnd=} [properties] Properties to set\n         */\n        function BroadcastDealerRoundEnd(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BroadcastDealerRoundEnd header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof dealer.BroadcastDealerRoundEnd\n         * @instance\n         */\n        BroadcastDealerRoundEnd.prototype.header = null;\n\n        /**\n         * Creates a new BroadcastDealerRoundEnd instance using the specified properties.\n         * @function create\n         * @memberof dealer.BroadcastDealerRoundEnd\n         * @static\n         * @param {dealer.IBroadcastDealerRoundEnd=} [properties] Properties to set\n         * @returns {dealer.BroadcastDealerRoundEnd} BroadcastDealerRoundEnd instance\n         */\n        BroadcastDealerRoundEnd.create = function create(properties) {\n            return new BroadcastDealerRoundEnd(properties);\n        };\n\n        /**\n         * Encodes the specified BroadcastDealerRoundEnd message. Does not implicitly {@link dealer.BroadcastDealerRoundEnd.verify|verify} messages.\n         * @function encode\n         * @memberof dealer.BroadcastDealerRoundEnd\n         * @static\n         * @param {dealer.IBroadcastDealerRoundEnd} message BroadcastDealerRoundEnd message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BroadcastDealerRoundEnd.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BroadcastDealerRoundEnd message, length delimited. Does not implicitly {@link dealer.BroadcastDealerRoundEnd.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof dealer.BroadcastDealerRoundEnd\n         * @static\n         * @param {dealer.IBroadcastDealerRoundEnd} message BroadcastDealerRoundEnd message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BroadcastDealerRoundEnd.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BroadcastDealerRoundEnd message from the specified reader or buffer.\n         * @function decode\n         * @memberof dealer.BroadcastDealerRoundEnd\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {dealer.BroadcastDealerRoundEnd} BroadcastDealerRoundEnd\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BroadcastDealerRoundEnd.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dealer.BroadcastDealerRoundEnd();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BroadcastDealerRoundEnd message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof dealer.BroadcastDealerRoundEnd\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {dealer.BroadcastDealerRoundEnd} BroadcastDealerRoundEnd\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BroadcastDealerRoundEnd.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BroadcastDealerRoundEnd message.\n         * @function verify\n         * @memberof dealer.BroadcastDealerRoundEnd\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BroadcastDealerRoundEnd.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BroadcastDealerRoundEnd message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof dealer.BroadcastDealerRoundEnd\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {dealer.BroadcastDealerRoundEnd} BroadcastDealerRoundEnd\n         */\n        BroadcastDealerRoundEnd.fromObject = function fromObject(object) {\n            if (object instanceof $root.dealer.BroadcastDealerRoundEnd)\n                return object;\n            let message = new $root.dealer.BroadcastDealerRoundEnd();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".dealer.BroadcastDealerRoundEnd.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BroadcastDealerRoundEnd message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof dealer.BroadcastDealerRoundEnd\n         * @static\n         * @param {dealer.BroadcastDealerRoundEnd} message BroadcastDealerRoundEnd\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BroadcastDealerRoundEnd.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults)\n                object.header = null;\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            return object;\n        };\n\n        /**\n         * Converts this BroadcastDealerRoundEnd to JSON.\n         * @function toJSON\n         * @memberof dealer.BroadcastDealerRoundEnd\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BroadcastDealerRoundEnd.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BroadcastDealerRoundEnd;\n    })();\n\n    /**\n     * Result enum.\n     * @name dealer.Result\n     * @enum {number}\n     * @property {number} Default=0 Default value\n     * @property {number} Banker=1 Banker value\n     * @property {number} Player=2 Player value\n     * @property {number} BankerPair=3 BankerPair value\n     * @property {number} Tie=4 Tie value\n     * @property {number} PlayerPair=5 PlayerPair value\n     */\n    dealer.Result = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Default\"] = 0;\n        values[valuesById[1] = \"Banker\"] = 1;\n        values[valuesById[2] = \"Player\"] = 2;\n        values[valuesById[3] = \"BankerPair\"] = 3;\n        values[valuesById[4] = \"Tie\"] = 4;\n        values[valuesById[5] = \"PlayerPair\"] = 5;\n        return values;\n    })();\n\n    dealer.GameResult = (function() {\n\n        /**\n         * Properties of a GameResult.\n         * @memberof dealer\n         * @interface IGameResult\n         * @property {foundation.IHeader|null} [header] GameResult header\n         * @property {Array.<dealer.Result>|null} [results] GameResult results\n         * @property {number|null} [totalWin] GameResult totalWin\n         */\n\n        /**\n         * Constructs a new GameResult.\n         * @memberof dealer\n         * @classdesc Represents a GameResult.\n         * @implements IGameResult\n         * @constructor\n         * @param {dealer.IGameResult=} [properties] Properties to set\n         */\n        function GameResult(properties) {\n            this.results = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * GameResult header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof dealer.GameResult\n         * @instance\n         */\n        GameResult.prototype.header = null;\n\n        /**\n         * GameResult results.\n         * @member {Array.<dealer.Result>} results\n         * @memberof dealer.GameResult\n         * @instance\n         */\n        GameResult.prototype.results = $util.emptyArray;\n\n        /**\n         * GameResult totalWin.\n         * @member {number} totalWin\n         * @memberof dealer.GameResult\n         * @instance\n         */\n        GameResult.prototype.totalWin = 0;\n\n        /**\n         * Creates a new GameResult instance using the specified properties.\n         * @function create\n         * @memberof dealer.GameResult\n         * @static\n         * @param {dealer.IGameResult=} [properties] Properties to set\n         * @returns {dealer.GameResult} GameResult instance\n         */\n        GameResult.create = function create(properties) {\n            return new GameResult(properties);\n        };\n\n        /**\n         * Encodes the specified GameResult message. Does not implicitly {@link dealer.GameResult.verify|verify} messages.\n         * @function encode\n         * @memberof dealer.GameResult\n         * @static\n         * @param {dealer.IGameResult} message GameResult message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GameResult.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.results != null && message.results.length) {\n                writer.uint32(/* id 2, wireType 2 =*/18).fork();\n                for (let i = 0; i < message.results.length; ++i)\n                    writer.int32(message.results[i]);\n                writer.ldelim();\n            }\n            if (message.totalWin != null && Object.hasOwnProperty.call(message, \"totalWin\"))\n                writer.uint32(/* id 3, wireType 1 =*/25).double(message.totalWin);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified GameResult message, length delimited. Does not implicitly {@link dealer.GameResult.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof dealer.GameResult\n         * @static\n         * @param {dealer.IGameResult} message GameResult message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GameResult.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a GameResult message from the specified reader or buffer.\n         * @function decode\n         * @memberof dealer.GameResult\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {dealer.GameResult} GameResult\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GameResult.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dealer.GameResult();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    if (!(message.results && message.results.length))\n                        message.results = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.results.push(reader.int32());\n                    } else\n                        message.results.push(reader.int32());\n                    break;\n                case 3:\n                    message.totalWin = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a GameResult message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof dealer.GameResult\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {dealer.GameResult} GameResult\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GameResult.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a GameResult message.\n         * @function verify\n         * @memberof dealer.GameResult\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        GameResult.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.results != null && message.hasOwnProperty(\"results\")) {\n                if (!Array.isArray(message.results))\n                    return \"results: array expected\";\n                for (let i = 0; i < message.results.length; ++i)\n                    switch (message.results[i]) {\n                    default:\n                        return \"results: enum value[] expected\";\n                    case 0:\n                    case 1:\n                    case 2:\n                    case 3:\n                    case 4:\n                    case 5:\n                        break;\n                    }\n            }\n            if (message.totalWin != null && message.hasOwnProperty(\"totalWin\"))\n                if (typeof message.totalWin !== \"number\")\n                    return \"totalWin: number expected\";\n            return null;\n        };\n\n        /**\n         * Creates a GameResult message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof dealer.GameResult\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {dealer.GameResult} GameResult\n         */\n        GameResult.fromObject = function fromObject(object) {\n            if (object instanceof $root.dealer.GameResult)\n                return object;\n            let message = new $root.dealer.GameResult();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".dealer.GameResult.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.results) {\n                if (!Array.isArray(object.results))\n                    throw TypeError(\".dealer.GameResult.results: array expected\");\n                message.results = [];\n                for (let i = 0; i < object.results.length; ++i)\n                    switch (object.results[i]) {\n                    default:\n                    case \"Default\":\n                    case 0:\n                        message.results[i] = 0;\n                        break;\n                    case \"Banker\":\n                    case 1:\n                        message.results[i] = 1;\n                        break;\n                    case \"Player\":\n                    case 2:\n                        message.results[i] = 2;\n                        break;\n                    case \"BankerPair\":\n                    case 3:\n                        message.results[i] = 3;\n                        break;\n                    case \"Tie\":\n                    case 4:\n                        message.results[i] = 4;\n                        break;\n                    case \"PlayerPair\":\n                    case 5:\n                        message.results[i] = 5;\n                        break;\n                    }\n            }\n            if (object.totalWin != null)\n                message.totalWin = Number(object.totalWin);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a GameResult message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof dealer.GameResult\n         * @static\n         * @param {dealer.GameResult} message GameResult\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        GameResult.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.arrays || options.defaults)\n                object.results = [];\n            if (options.defaults) {\n                object.header = null;\n                object.totalWin = 0;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.results && message.results.length) {\n                object.results = [];\n                for (let j = 0; j < message.results.length; ++j)\n                    object.results[j] = options.enums === String ? $root.dealer.Result[message.results[j]] : message.results[j];\n            }\n            if (message.totalWin != null && message.hasOwnProperty(\"totalWin\"))\n                object.totalWin = options.json && !isFinite(message.totalWin) ? String(message.totalWin) : message.totalWin;\n            return object;\n        };\n\n        /**\n         * Converts this GameResult to JSON.\n         * @function toJSON\n         * @memberof dealer.GameResult\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        GameResult.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return GameResult;\n    })();\n\n    dealer.GameStatus = (function() {\n\n        /**\n         * Properties of a GameStatus.\n         * @memberof dealer\n         * @interface IGameStatus\n         * @property {foundation.IHeader|null} [header] GameStatus header\n         * @property {boolean|null} [isGaming] GameStatus isGaming\n         */\n\n        /**\n         * Constructs a new GameStatus.\n         * @memberof dealer\n         * @classdesc Represents a GameStatus.\n         * @implements IGameStatus\n         * @constructor\n         * @param {dealer.IGameStatus=} [properties] Properties to set\n         */\n        function GameStatus(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * GameStatus header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof dealer.GameStatus\n         * @instance\n         */\n        GameStatus.prototype.header = null;\n\n        /**\n         * GameStatus isGaming.\n         * @member {boolean} isGaming\n         * @memberof dealer.GameStatus\n         * @instance\n         */\n        GameStatus.prototype.isGaming = false;\n\n        /**\n         * Creates a new GameStatus instance using the specified properties.\n         * @function create\n         * @memberof dealer.GameStatus\n         * @static\n         * @param {dealer.IGameStatus=} [properties] Properties to set\n         * @returns {dealer.GameStatus} GameStatus instance\n         */\n        GameStatus.create = function create(properties) {\n            return new GameStatus(properties);\n        };\n\n        /**\n         * Encodes the specified GameStatus message. Does not implicitly {@link dealer.GameStatus.verify|verify} messages.\n         * @function encode\n         * @memberof dealer.GameStatus\n         * @static\n         * @param {dealer.IGameStatus} message GameStatus message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GameStatus.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.isGaming != null && Object.hasOwnProperty.call(message, \"isGaming\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isGaming);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified GameStatus message, length delimited. Does not implicitly {@link dealer.GameStatus.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof dealer.GameStatus\n         * @static\n         * @param {dealer.IGameStatus} message GameStatus message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GameStatus.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a GameStatus message from the specified reader or buffer.\n         * @function decode\n         * @memberof dealer.GameStatus\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {dealer.GameStatus} GameStatus\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GameStatus.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dealer.GameStatus();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.isGaming = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a GameStatus message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof dealer.GameStatus\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {dealer.GameStatus} GameStatus\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GameStatus.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a GameStatus message.\n         * @function verify\n         * @memberof dealer.GameStatus\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        GameStatus.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.isGaming != null && message.hasOwnProperty(\"isGaming\"))\n                if (typeof message.isGaming !== \"boolean\")\n                    return \"isGaming: boolean expected\";\n            return null;\n        };\n\n        /**\n         * Creates a GameStatus message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof dealer.GameStatus\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {dealer.GameStatus} GameStatus\n         */\n        GameStatus.fromObject = function fromObject(object) {\n            if (object instanceof $root.dealer.GameStatus)\n                return object;\n            let message = new $root.dealer.GameStatus();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".dealer.GameStatus.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.isGaming != null)\n                message.isGaming = Boolean(object.isGaming);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a GameStatus message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof dealer.GameStatus\n         * @static\n         * @param {dealer.GameStatus} message GameStatus\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        GameStatus.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.isGaming = false;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.isGaming != null && message.hasOwnProperty(\"isGaming\"))\n                object.isGaming = message.isGaming;\n            return object;\n        };\n\n        /**\n         * Converts this GameStatus to JSON.\n         * @function toJSON\n         * @memberof dealer.GameStatus\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        GameStatus.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return GameStatus;\n    })();\n\n    return dealer;\n})();\n\nexport const foundation = $root.foundation = (() => {\n\n    /**\n     * Namespace foundation.\n     * @exports foundation\n     * @namespace\n     */\n    const foundation = {};\n\n    foundation.Header = (function() {\n\n        /**\n         * Properties of a Header.\n         * @memberof foundation\n         * @interface IHeader\n         * @property {route.URI|null} [uri] Header uri\n         */\n\n        /**\n         * Constructs a new Header.\n         * @memberof foundation\n         * @classdesc Represents a Header.\n         * @implements IHeader\n         * @constructor\n         * @param {foundation.IHeader=} [properties] Properties to set\n         */\n        function Header(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Header uri.\n         * @member {route.URI} uri\n         * @memberof foundation.Header\n         * @instance\n         */\n        Header.prototype.uri = 0;\n\n        /**\n         * Creates a new Header instance using the specified properties.\n         * @function create\n         * @memberof foundation.Header\n         * @static\n         * @param {foundation.IHeader=} [properties] Properties to set\n         * @returns {foundation.Header} Header instance\n         */\n        Header.create = function create(properties) {\n            return new Header(properties);\n        };\n\n        /**\n         * Encodes the specified Header message. Does not implicitly {@link foundation.Header.verify|verify} messages.\n         * @function encode\n         * @memberof foundation.Header\n         * @static\n         * @param {foundation.IHeader} message Header message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Header.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.uri != null && Object.hasOwnProperty.call(message, \"uri\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.uri);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Header message, length delimited. Does not implicitly {@link foundation.Header.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof foundation.Header\n         * @static\n         * @param {foundation.IHeader} message Header message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Header.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Header message from the specified reader or buffer.\n         * @function decode\n         * @memberof foundation.Header\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {foundation.Header} Header\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Header.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.foundation.Header();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.uri = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Header message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof foundation.Header\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {foundation.Header} Header\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Header.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Header message.\n         * @function verify\n         * @memberof foundation.Header\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Header.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.uri != null && message.hasOwnProperty(\"uri\"))\n                switch (message.uri) {\n                default:\n                    return \"uri: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                case 9:\n                case 10:\n                case 11:\n                case 12:\n                case 13:\n                case 14:\n                case 15:\n                case 16:\n                case 17:\n                case 18:\n                case 19:\n                case 20:\n                case 21:\n                case 22:\n                case 220:\n                case 23:\n                case 24:\n                case 25:\n                case 26:\n                    break;\n                }\n            return null;\n        };\n\n        /**\n         * Creates a Header message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof foundation.Header\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {foundation.Header} Header\n         */\n        Header.fromObject = function fromObject(object) {\n            if (object instanceof $root.foundation.Header)\n                return object;\n            let message = new $root.foundation.Header();\n            switch (object.uri) {\n            case \"Default\":\n            case 0:\n                message.uri = 0;\n                break;\n            case \"LoginCall\":\n            case 1:\n                message.uri = 1;\n                break;\n            case \"LoginRecall\":\n            case 2:\n                message.uri = 2;\n                break;\n            case \"LobbyInfo\":\n            case 3:\n                message.uri = 3;\n                break;\n            case \"UserInfo\":\n            case 4:\n                message.uri = 4;\n                break;\n            case \"TableJoinCall\":\n            case 5:\n                message.uri = 5;\n                break;\n            case \"TableJoinRecall\":\n            case 6:\n                message.uri = 6;\n                break;\n            case \"BetCall\":\n            case 7:\n                message.uri = 7;\n                break;\n            case \"BetRecall\":\n            case 8:\n                message.uri = 8;\n                break;\n            case \"BetResetCall\":\n            case 9:\n                message.uri = 9;\n                break;\n            case \"BetResetRecall\":\n            case 10:\n                message.uri = 10;\n                break;\n            case \"Draw\":\n            case 11:\n                message.uri = 11;\n                break;\n            case \"DealerGameResult\":\n            case 12:\n                message.uri = 12;\n                break;\n            case \"BroadcastGameResult\":\n            case 13:\n                message.uri = 13;\n                break;\n            case \"BetRoundStart\":\n            case 14:\n                message.uri = 14;\n                break;\n            case \"BetRoundEnd\":\n            case 15:\n                message.uri = 15;\n                break;\n            case \"BetRoundCountdown\":\n            case 16:\n                message.uri = 16;\n                break;\n            case \"HeartbeatPing\":\n            case 17:\n                message.uri = 17;\n                break;\n            case \"HeartbeatPong\":\n            case 18:\n                message.uri = 18;\n                break;\n            case \"DealerRoundStartCall\":\n            case 19:\n                message.uri = 19;\n                break;\n            case \"DealerRoundStartRecall\":\n            case 20:\n                message.uri = 20;\n                break;\n            case \"DealerRoundEndCall\":\n            case 21:\n                message.uri = 21;\n                break;\n            case \"DealerRoundEndRecall\":\n            case 22:\n                message.uri = 22;\n                break;\n            case \"BroadcastDealerRoundEnd\":\n            case 220:\n                message.uri = 220;\n                break;\n            case \"BetError\":\n            case 23:\n                message.uri = 23;\n                break;\n            case \"GameStatus\":\n            case 24:\n                message.uri = 24;\n                break;\n            case \"DealerGameStatus\":\n            case 25:\n                message.uri = 25;\n                break;\n            case \"Roadmap\":\n            case 26:\n                message.uri = 26;\n                break;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Header message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof foundation.Header\n         * @static\n         * @param {foundation.Header} message Header\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Header.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults)\n                object.uri = options.enums === String ? \"Default\" : 0;\n            if (message.uri != null && message.hasOwnProperty(\"uri\"))\n                object.uri = options.enums === String ? $root.route.URI[message.uri] : message.uri;\n            return object;\n        };\n\n        /**\n         * Converts this Header to JSON.\n         * @function toJSON\n         * @memberof foundation.Header\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Header.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Header;\n    })();\n\n    foundation.HeartbeatPing = (function() {\n\n        /**\n         * Properties of a HeartbeatPing.\n         * @memberof foundation\n         * @interface IHeartbeatPing\n         * @property {foundation.IHeader|null} [header] HeartbeatPing header\n         */\n\n        /**\n         * Constructs a new HeartbeatPing.\n         * @memberof foundation\n         * @classdesc Represents a HeartbeatPing.\n         * @implements IHeartbeatPing\n         * @constructor\n         * @param {foundation.IHeartbeatPing=} [properties] Properties to set\n         */\n        function HeartbeatPing(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * HeartbeatPing header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof foundation.HeartbeatPing\n         * @instance\n         */\n        HeartbeatPing.prototype.header = null;\n\n        /**\n         * Creates a new HeartbeatPing instance using the specified properties.\n         * @function create\n         * @memberof foundation.HeartbeatPing\n         * @static\n         * @param {foundation.IHeartbeatPing=} [properties] Properties to set\n         * @returns {foundation.HeartbeatPing} HeartbeatPing instance\n         */\n        HeartbeatPing.create = function create(properties) {\n            return new HeartbeatPing(properties);\n        };\n\n        /**\n         * Encodes the specified HeartbeatPing message. Does not implicitly {@link foundation.HeartbeatPing.verify|verify} messages.\n         * @function encode\n         * @memberof foundation.HeartbeatPing\n         * @static\n         * @param {foundation.IHeartbeatPing} message HeartbeatPing message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HeartbeatPing.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified HeartbeatPing message, length delimited. Does not implicitly {@link foundation.HeartbeatPing.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof foundation.HeartbeatPing\n         * @static\n         * @param {foundation.IHeartbeatPing} message HeartbeatPing message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HeartbeatPing.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a HeartbeatPing message from the specified reader or buffer.\n         * @function decode\n         * @memberof foundation.HeartbeatPing\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {foundation.HeartbeatPing} HeartbeatPing\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HeartbeatPing.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.foundation.HeartbeatPing();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a HeartbeatPing message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof foundation.HeartbeatPing\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {foundation.HeartbeatPing} HeartbeatPing\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HeartbeatPing.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a HeartbeatPing message.\n         * @function verify\n         * @memberof foundation.HeartbeatPing\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        HeartbeatPing.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a HeartbeatPing message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof foundation.HeartbeatPing\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {foundation.HeartbeatPing} HeartbeatPing\n         */\n        HeartbeatPing.fromObject = function fromObject(object) {\n            if (object instanceof $root.foundation.HeartbeatPing)\n                return object;\n            let message = new $root.foundation.HeartbeatPing();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".foundation.HeartbeatPing.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a HeartbeatPing message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof foundation.HeartbeatPing\n         * @static\n         * @param {foundation.HeartbeatPing} message HeartbeatPing\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        HeartbeatPing.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults)\n                object.header = null;\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            return object;\n        };\n\n        /**\n         * Converts this HeartbeatPing to JSON.\n         * @function toJSON\n         * @memberof foundation.HeartbeatPing\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        HeartbeatPing.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return HeartbeatPing;\n    })();\n\n    foundation.HeartbeatPong = (function() {\n\n        /**\n         * Properties of a HeartbeatPong.\n         * @memberof foundation\n         * @interface IHeartbeatPong\n         * @property {foundation.IHeader|null} [header] HeartbeatPong header\n         */\n\n        /**\n         * Constructs a new HeartbeatPong.\n         * @memberof foundation\n         * @classdesc Represents a HeartbeatPong.\n         * @implements IHeartbeatPong\n         * @constructor\n         * @param {foundation.IHeartbeatPong=} [properties] Properties to set\n         */\n        function HeartbeatPong(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * HeartbeatPong header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof foundation.HeartbeatPong\n         * @instance\n         */\n        HeartbeatPong.prototype.header = null;\n\n        /**\n         * Creates a new HeartbeatPong instance using the specified properties.\n         * @function create\n         * @memberof foundation.HeartbeatPong\n         * @static\n         * @param {foundation.IHeartbeatPong=} [properties] Properties to set\n         * @returns {foundation.HeartbeatPong} HeartbeatPong instance\n         */\n        HeartbeatPong.create = function create(properties) {\n            return new HeartbeatPong(properties);\n        };\n\n        /**\n         * Encodes the specified HeartbeatPong message. Does not implicitly {@link foundation.HeartbeatPong.verify|verify} messages.\n         * @function encode\n         * @memberof foundation.HeartbeatPong\n         * @static\n         * @param {foundation.IHeartbeatPong} message HeartbeatPong message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HeartbeatPong.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified HeartbeatPong message, length delimited. Does not implicitly {@link foundation.HeartbeatPong.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof foundation.HeartbeatPong\n         * @static\n         * @param {foundation.IHeartbeatPong} message HeartbeatPong message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HeartbeatPong.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a HeartbeatPong message from the specified reader or buffer.\n         * @function decode\n         * @memberof foundation.HeartbeatPong\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {foundation.HeartbeatPong} HeartbeatPong\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HeartbeatPong.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.foundation.HeartbeatPong();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a HeartbeatPong message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof foundation.HeartbeatPong\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {foundation.HeartbeatPong} HeartbeatPong\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HeartbeatPong.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a HeartbeatPong message.\n         * @function verify\n         * @memberof foundation.HeartbeatPong\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        HeartbeatPong.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a HeartbeatPong message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof foundation.HeartbeatPong\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {foundation.HeartbeatPong} HeartbeatPong\n         */\n        HeartbeatPong.fromObject = function fromObject(object) {\n            if (object instanceof $root.foundation.HeartbeatPong)\n                return object;\n            let message = new $root.foundation.HeartbeatPong();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".foundation.HeartbeatPong.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a HeartbeatPong message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof foundation.HeartbeatPong\n         * @static\n         * @param {foundation.HeartbeatPong} message HeartbeatPong\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        HeartbeatPong.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults)\n                object.header = null;\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            return object;\n        };\n\n        /**\n         * Converts this HeartbeatPong to JSON.\n         * @function toJSON\n         * @memberof foundation.HeartbeatPong\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        HeartbeatPong.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return HeartbeatPong;\n    })();\n\n    foundation.Message = (function() {\n\n        /**\n         * Properties of a Message.\n         * @memberof foundation\n         * @interface IMessage\n         * @property {foundation.IHeader|null} [header] Message header\n         */\n\n        /**\n         * Constructs a new Message.\n         * @memberof foundation\n         * @classdesc Represents a Message.\n         * @implements IMessage\n         * @constructor\n         * @param {foundation.IMessage=} [properties] Properties to set\n         */\n        function Message(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Message header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof foundation.Message\n         * @instance\n         */\n        Message.prototype.header = null;\n\n        /**\n         * Creates a new Message instance using the specified properties.\n         * @function create\n         * @memberof foundation.Message\n         * @static\n         * @param {foundation.IMessage=} [properties] Properties to set\n         * @returns {foundation.Message} Message instance\n         */\n        Message.create = function create(properties) {\n            return new Message(properties);\n        };\n\n        /**\n         * Encodes the specified Message message. Does not implicitly {@link foundation.Message.verify|verify} messages.\n         * @function encode\n         * @memberof foundation.Message\n         * @static\n         * @param {foundation.IMessage} message Message message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Message.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Message message, length delimited. Does not implicitly {@link foundation.Message.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof foundation.Message\n         * @static\n         * @param {foundation.IMessage} message Message message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Message.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Message message from the specified reader or buffer.\n         * @function decode\n         * @memberof foundation.Message\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {foundation.Message} Message\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Message.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.foundation.Message();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Message message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof foundation.Message\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {foundation.Message} Message\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Message.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Message message.\n         * @function verify\n         * @memberof foundation.Message\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Message.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a Message message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof foundation.Message\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {foundation.Message} Message\n         */\n        Message.fromObject = function fromObject(object) {\n            if (object instanceof $root.foundation.Message)\n                return object;\n            let message = new $root.foundation.Message();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".foundation.Message.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Message message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof foundation.Message\n         * @static\n         * @param {foundation.Message} message Message\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Message.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults)\n                object.header = null;\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            return object;\n        };\n\n        /**\n         * Converts this Message to JSON.\n         * @function toJSON\n         * @memberof foundation.Message\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Message.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Message;\n    })();\n\n    return foundation;\n})();\n\nexport const game = $root.game = (() => {\n\n    /**\n     * Namespace game.\n     * @exports game\n     * @namespace\n     */\n    const game = {};\n\n    /**\n     * Status enum.\n     * @name game.Status\n     * @enum {number}\n     * @property {number} default=0 default value\n     * @property {number} beting=1 beting value\n     * @property {number} drawing=2 drawing value\n     * @property {number} waiting=3 waiting value\n     */\n    game.Status = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"default\"] = 0;\n        values[valuesById[1] = \"beting\"] = 1;\n        values[valuesById[2] = \"drawing\"] = 2;\n        values[valuesById[3] = \"waiting\"] = 3;\n        return values;\n    })();\n\n    game.BetRoundStart = (function() {\n\n        /**\n         * Properties of a BetRoundStart.\n         * @memberof game\n         * @interface IBetRoundStart\n         * @property {foundation.IHeader|null} [header] BetRoundStart header\n         * @property {string|null} [gameUuid] BetRoundStart gameUuid\n         * @property {number|null} [timeRemain] BetRoundStart timeRemain\n         */\n\n        /**\n         * Constructs a new BetRoundStart.\n         * @memberof game\n         * @classdesc Represents a BetRoundStart.\n         * @implements IBetRoundStart\n         * @constructor\n         * @param {game.IBetRoundStart=} [properties] Properties to set\n         */\n        function BetRoundStart(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BetRoundStart header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof game.BetRoundStart\n         * @instance\n         */\n        BetRoundStart.prototype.header = null;\n\n        /**\n         * BetRoundStart gameUuid.\n         * @member {string} gameUuid\n         * @memberof game.BetRoundStart\n         * @instance\n         */\n        BetRoundStart.prototype.gameUuid = \"\";\n\n        /**\n         * BetRoundStart timeRemain.\n         * @member {number} timeRemain\n         * @memberof game.BetRoundStart\n         * @instance\n         */\n        BetRoundStart.prototype.timeRemain = 0;\n\n        /**\n         * Creates a new BetRoundStart instance using the specified properties.\n         * @function create\n         * @memberof game.BetRoundStart\n         * @static\n         * @param {game.IBetRoundStart=} [properties] Properties to set\n         * @returns {game.BetRoundStart} BetRoundStart instance\n         */\n        BetRoundStart.create = function create(properties) {\n            return new BetRoundStart(properties);\n        };\n\n        /**\n         * Encodes the specified BetRoundStart message. Does not implicitly {@link game.BetRoundStart.verify|verify} messages.\n         * @function encode\n         * @memberof game.BetRoundStart\n         * @static\n         * @param {game.IBetRoundStart} message BetRoundStart message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetRoundStart.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.gameUuid != null && Object.hasOwnProperty.call(message, \"gameUuid\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gameUuid);\n            if (message.timeRemain != null && Object.hasOwnProperty.call(message, \"timeRemain\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.timeRemain);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BetRoundStart message, length delimited. Does not implicitly {@link game.BetRoundStart.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof game.BetRoundStart\n         * @static\n         * @param {game.IBetRoundStart} message BetRoundStart message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetRoundStart.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BetRoundStart message from the specified reader or buffer.\n         * @function decode\n         * @memberof game.BetRoundStart\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {game.BetRoundStart} BetRoundStart\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetRoundStart.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.game.BetRoundStart();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.gameUuid = reader.string();\n                    break;\n                case 3:\n                    message.timeRemain = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BetRoundStart message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof game.BetRoundStart\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {game.BetRoundStart} BetRoundStart\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetRoundStart.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BetRoundStart message.\n         * @function verify\n         * @memberof game.BetRoundStart\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BetRoundStart.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.gameUuid != null && message.hasOwnProperty(\"gameUuid\"))\n                if (!$util.isString(message.gameUuid))\n                    return \"gameUuid: string expected\";\n            if (message.timeRemain != null && message.hasOwnProperty(\"timeRemain\"))\n                if (!$util.isInteger(message.timeRemain))\n                    return \"timeRemain: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a BetRoundStart message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof game.BetRoundStart\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {game.BetRoundStart} BetRoundStart\n         */\n        BetRoundStart.fromObject = function fromObject(object) {\n            if (object instanceof $root.game.BetRoundStart)\n                return object;\n            let message = new $root.game.BetRoundStart();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".game.BetRoundStart.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.gameUuid != null)\n                message.gameUuid = String(object.gameUuid);\n            if (object.timeRemain != null)\n                message.timeRemain = object.timeRemain | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BetRoundStart message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof game.BetRoundStart\n         * @static\n         * @param {game.BetRoundStart} message BetRoundStart\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BetRoundStart.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.gameUuid = \"\";\n                object.timeRemain = 0;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.gameUuid != null && message.hasOwnProperty(\"gameUuid\"))\n                object.gameUuid = message.gameUuid;\n            if (message.timeRemain != null && message.hasOwnProperty(\"timeRemain\"))\n                object.timeRemain = message.timeRemain;\n            return object;\n        };\n\n        /**\n         * Converts this BetRoundStart to JSON.\n         * @function toJSON\n         * @memberof game.BetRoundStart\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BetRoundStart.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BetRoundStart;\n    })();\n\n    game.BetRoundCountdown = (function() {\n\n        /**\n         * Properties of a BetRoundCountdown.\n         * @memberof game\n         * @interface IBetRoundCountdown\n         * @property {foundation.IHeader|null} [header] BetRoundCountdown header\n         * @property {number|null} [timeRemain] BetRoundCountdown timeRemain\n         */\n\n        /**\n         * Constructs a new BetRoundCountdown.\n         * @memberof game\n         * @classdesc Represents a BetRoundCountdown.\n         * @implements IBetRoundCountdown\n         * @constructor\n         * @param {game.IBetRoundCountdown=} [properties] Properties to set\n         */\n        function BetRoundCountdown(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BetRoundCountdown header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof game.BetRoundCountdown\n         * @instance\n         */\n        BetRoundCountdown.prototype.header = null;\n\n        /**\n         * BetRoundCountdown timeRemain.\n         * @member {number} timeRemain\n         * @memberof game.BetRoundCountdown\n         * @instance\n         */\n        BetRoundCountdown.prototype.timeRemain = 0;\n\n        /**\n         * Creates a new BetRoundCountdown instance using the specified properties.\n         * @function create\n         * @memberof game.BetRoundCountdown\n         * @static\n         * @param {game.IBetRoundCountdown=} [properties] Properties to set\n         * @returns {game.BetRoundCountdown} BetRoundCountdown instance\n         */\n        BetRoundCountdown.create = function create(properties) {\n            return new BetRoundCountdown(properties);\n        };\n\n        /**\n         * Encodes the specified BetRoundCountdown message. Does not implicitly {@link game.BetRoundCountdown.verify|verify} messages.\n         * @function encode\n         * @memberof game.BetRoundCountdown\n         * @static\n         * @param {game.IBetRoundCountdown} message BetRoundCountdown message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetRoundCountdown.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.timeRemain != null && Object.hasOwnProperty.call(message, \"timeRemain\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.timeRemain);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BetRoundCountdown message, length delimited. Does not implicitly {@link game.BetRoundCountdown.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof game.BetRoundCountdown\n         * @static\n         * @param {game.IBetRoundCountdown} message BetRoundCountdown message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetRoundCountdown.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BetRoundCountdown message from the specified reader or buffer.\n         * @function decode\n         * @memberof game.BetRoundCountdown\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {game.BetRoundCountdown} BetRoundCountdown\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetRoundCountdown.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.game.BetRoundCountdown();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.timeRemain = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BetRoundCountdown message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof game.BetRoundCountdown\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {game.BetRoundCountdown} BetRoundCountdown\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetRoundCountdown.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BetRoundCountdown message.\n         * @function verify\n         * @memberof game.BetRoundCountdown\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BetRoundCountdown.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.timeRemain != null && message.hasOwnProperty(\"timeRemain\"))\n                if (!$util.isInteger(message.timeRemain))\n                    return \"timeRemain: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a BetRoundCountdown message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof game.BetRoundCountdown\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {game.BetRoundCountdown} BetRoundCountdown\n         */\n        BetRoundCountdown.fromObject = function fromObject(object) {\n            if (object instanceof $root.game.BetRoundCountdown)\n                return object;\n            let message = new $root.game.BetRoundCountdown();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".game.BetRoundCountdown.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.timeRemain != null)\n                message.timeRemain = object.timeRemain | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BetRoundCountdown message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof game.BetRoundCountdown\n         * @static\n         * @param {game.BetRoundCountdown} message BetRoundCountdown\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BetRoundCountdown.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.timeRemain = 0;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.timeRemain != null && message.hasOwnProperty(\"timeRemain\"))\n                object.timeRemain = message.timeRemain;\n            return object;\n        };\n\n        /**\n         * Converts this BetRoundCountdown to JSON.\n         * @function toJSON\n         * @memberof game.BetRoundCountdown\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BetRoundCountdown.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BetRoundCountdown;\n    })();\n\n    game.BetRoundEnd = (function() {\n\n        /**\n         * Properties of a BetRoundEnd.\n         * @memberof game\n         * @interface IBetRoundEnd\n         * @property {foundation.IHeader|null} [header] BetRoundEnd header\n         * @property {string|null} [gameUuid] BetRoundEnd gameUuid\n         */\n\n        /**\n         * Constructs a new BetRoundEnd.\n         * @memberof game\n         * @classdesc Represents a BetRoundEnd.\n         * @implements IBetRoundEnd\n         * @constructor\n         * @param {game.IBetRoundEnd=} [properties] Properties to set\n         */\n        function BetRoundEnd(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BetRoundEnd header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof game.BetRoundEnd\n         * @instance\n         */\n        BetRoundEnd.prototype.header = null;\n\n        /**\n         * BetRoundEnd gameUuid.\n         * @member {string} gameUuid\n         * @memberof game.BetRoundEnd\n         * @instance\n         */\n        BetRoundEnd.prototype.gameUuid = \"\";\n\n        /**\n         * Creates a new BetRoundEnd instance using the specified properties.\n         * @function create\n         * @memberof game.BetRoundEnd\n         * @static\n         * @param {game.IBetRoundEnd=} [properties] Properties to set\n         * @returns {game.BetRoundEnd} BetRoundEnd instance\n         */\n        BetRoundEnd.create = function create(properties) {\n            return new BetRoundEnd(properties);\n        };\n\n        /**\n         * Encodes the specified BetRoundEnd message. Does not implicitly {@link game.BetRoundEnd.verify|verify} messages.\n         * @function encode\n         * @memberof game.BetRoundEnd\n         * @static\n         * @param {game.IBetRoundEnd} message BetRoundEnd message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetRoundEnd.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.gameUuid != null && Object.hasOwnProperty.call(message, \"gameUuid\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gameUuid);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BetRoundEnd message, length delimited. Does not implicitly {@link game.BetRoundEnd.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof game.BetRoundEnd\n         * @static\n         * @param {game.IBetRoundEnd} message BetRoundEnd message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetRoundEnd.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BetRoundEnd message from the specified reader or buffer.\n         * @function decode\n         * @memberof game.BetRoundEnd\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {game.BetRoundEnd} BetRoundEnd\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetRoundEnd.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.game.BetRoundEnd();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.gameUuid = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BetRoundEnd message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof game.BetRoundEnd\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {game.BetRoundEnd} BetRoundEnd\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetRoundEnd.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BetRoundEnd message.\n         * @function verify\n         * @memberof game.BetRoundEnd\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BetRoundEnd.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.gameUuid != null && message.hasOwnProperty(\"gameUuid\"))\n                if (!$util.isString(message.gameUuid))\n                    return \"gameUuid: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a BetRoundEnd message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof game.BetRoundEnd\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {game.BetRoundEnd} BetRoundEnd\n         */\n        BetRoundEnd.fromObject = function fromObject(object) {\n            if (object instanceof $root.game.BetRoundEnd)\n                return object;\n            let message = new $root.game.BetRoundEnd();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".game.BetRoundEnd.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.gameUuid != null)\n                message.gameUuid = String(object.gameUuid);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BetRoundEnd message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof game.BetRoundEnd\n         * @static\n         * @param {game.BetRoundEnd} message BetRoundEnd\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BetRoundEnd.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.gameUuid = \"\";\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.gameUuid != null && message.hasOwnProperty(\"gameUuid\"))\n                object.gameUuid = message.gameUuid;\n            return object;\n        };\n\n        /**\n         * Converts this BetRoundEnd to JSON.\n         * @function toJSON\n         * @memberof game.BetRoundEnd\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BetRoundEnd.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BetRoundEnd;\n    })();\n\n    game.GameStatus = (function() {\n\n        /**\n         * Properties of a GameStatus.\n         * @memberof game\n         * @interface IGameStatus\n         * @property {foundation.IHeader|null} [header] GameStatus header\n         * @property {game.Status|null} [status] GameStatus status\n         * @property {number|null} [timeRemain] GameStatus timeRemain\n         * @property {Array.<dealer.IDraw>|null} [draws] GameStatus draws\n         */\n\n        /**\n         * Constructs a new GameStatus.\n         * @memberof game\n         * @classdesc Represents a GameStatus.\n         * @implements IGameStatus\n         * @constructor\n         * @param {game.IGameStatus=} [properties] Properties to set\n         */\n        function GameStatus(properties) {\n            this.draws = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * GameStatus header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof game.GameStatus\n         * @instance\n         */\n        GameStatus.prototype.header = null;\n\n        /**\n         * GameStatus status.\n         * @member {game.Status} status\n         * @memberof game.GameStatus\n         * @instance\n         */\n        GameStatus.prototype.status = 0;\n\n        /**\n         * GameStatus timeRemain.\n         * @member {number} timeRemain\n         * @memberof game.GameStatus\n         * @instance\n         */\n        GameStatus.prototype.timeRemain = 0;\n\n        /**\n         * GameStatus draws.\n         * @member {Array.<dealer.IDraw>} draws\n         * @memberof game.GameStatus\n         * @instance\n         */\n        GameStatus.prototype.draws = $util.emptyArray;\n\n        /**\n         * Creates a new GameStatus instance using the specified properties.\n         * @function create\n         * @memberof game.GameStatus\n         * @static\n         * @param {game.IGameStatus=} [properties] Properties to set\n         * @returns {game.GameStatus} GameStatus instance\n         */\n        GameStatus.create = function create(properties) {\n            return new GameStatus(properties);\n        };\n\n        /**\n         * Encodes the specified GameStatus message. Does not implicitly {@link game.GameStatus.verify|verify} messages.\n         * @function encode\n         * @memberof game.GameStatus\n         * @static\n         * @param {game.IGameStatus} message GameStatus message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GameStatus.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.status != null && Object.hasOwnProperty.call(message, \"status\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);\n            if (message.timeRemain != null && Object.hasOwnProperty.call(message, \"timeRemain\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.timeRemain);\n            if (message.draws != null && message.draws.length)\n                for (let i = 0; i < message.draws.length; ++i)\n                    $root.dealer.Draw.encode(message.draws[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified GameStatus message, length delimited. Does not implicitly {@link game.GameStatus.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof game.GameStatus\n         * @static\n         * @param {game.IGameStatus} message GameStatus message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GameStatus.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a GameStatus message from the specified reader or buffer.\n         * @function decode\n         * @memberof game.GameStatus\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {game.GameStatus} GameStatus\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GameStatus.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.game.GameStatus();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.status = reader.int32();\n                    break;\n                case 3:\n                    message.timeRemain = reader.int32();\n                    break;\n                case 4:\n                    if (!(message.draws && message.draws.length))\n                        message.draws = [];\n                    message.draws.push($root.dealer.Draw.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a GameStatus message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof game.GameStatus\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {game.GameStatus} GameStatus\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GameStatus.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a GameStatus message.\n         * @function verify\n         * @memberof game.GameStatus\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        GameStatus.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.status != null && message.hasOwnProperty(\"status\"))\n                switch (message.status) {\n                default:\n                    return \"status: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                    break;\n                }\n            if (message.timeRemain != null && message.hasOwnProperty(\"timeRemain\"))\n                if (!$util.isInteger(message.timeRemain))\n                    return \"timeRemain: integer expected\";\n            if (message.draws != null && message.hasOwnProperty(\"draws\")) {\n                if (!Array.isArray(message.draws))\n                    return \"draws: array expected\";\n                for (let i = 0; i < message.draws.length; ++i) {\n                    let error = $root.dealer.Draw.verify(message.draws[i]);\n                    if (error)\n                        return \"draws.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a GameStatus message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof game.GameStatus\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {game.GameStatus} GameStatus\n         */\n        GameStatus.fromObject = function fromObject(object) {\n            if (object instanceof $root.game.GameStatus)\n                return object;\n            let message = new $root.game.GameStatus();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".game.GameStatus.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            switch (object.status) {\n            case \"default\":\n            case 0:\n                message.status = 0;\n                break;\n            case \"beting\":\n            case 1:\n                message.status = 1;\n                break;\n            case \"drawing\":\n            case 2:\n                message.status = 2;\n                break;\n            case \"waiting\":\n            case 3:\n                message.status = 3;\n                break;\n            }\n            if (object.timeRemain != null)\n                message.timeRemain = object.timeRemain | 0;\n            if (object.draws) {\n                if (!Array.isArray(object.draws))\n                    throw TypeError(\".game.GameStatus.draws: array expected\");\n                message.draws = [];\n                for (let i = 0; i < object.draws.length; ++i) {\n                    if (typeof object.draws[i] !== \"object\")\n                        throw TypeError(\".game.GameStatus.draws: object expected\");\n                    message.draws[i] = $root.dealer.Draw.fromObject(object.draws[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a GameStatus message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof game.GameStatus\n         * @static\n         * @param {game.GameStatus} message GameStatus\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        GameStatus.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.arrays || options.defaults)\n                object.draws = [];\n            if (options.defaults) {\n                object.header = null;\n                object.status = options.enums === String ? \"default\" : 0;\n                object.timeRemain = 0;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.status != null && message.hasOwnProperty(\"status\"))\n                object.status = options.enums === String ? $root.game.Status[message.status] : message.status;\n            if (message.timeRemain != null && message.hasOwnProperty(\"timeRemain\"))\n                object.timeRemain = message.timeRemain;\n            if (message.draws && message.draws.length) {\n                object.draws = [];\n                for (let j = 0; j < message.draws.length; ++j)\n                    object.draws[j] = $root.dealer.Draw.toObject(message.draws[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this GameStatus to JSON.\n         * @function toJSON\n         * @memberof game.GameStatus\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        GameStatus.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return GameStatus;\n    })();\n\n    return game;\n})();\n\nexport const lobby = $root.lobby = (() => {\n\n    /**\n     * Namespace lobby.\n     * @exports lobby\n     * @namespace\n     */\n    const lobby = {};\n\n    lobby.LobbyInfo = (function() {\n\n        /**\n         * Properties of a LobbyInfo.\n         * @memberof lobby\n         * @interface ILobbyInfo\n         * @property {foundation.IHeader|null} [header] LobbyInfo header\n         * @property {Array.<lobby.ITableInfo>|null} [tables] LobbyInfo tables\n         */\n\n        /**\n         * Constructs a new LobbyInfo.\n         * @memberof lobby\n         * @classdesc Represents a LobbyInfo.\n         * @implements ILobbyInfo\n         * @constructor\n         * @param {lobby.ILobbyInfo=} [properties] Properties to set\n         */\n        function LobbyInfo(properties) {\n            this.tables = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LobbyInfo header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof lobby.LobbyInfo\n         * @instance\n         */\n        LobbyInfo.prototype.header = null;\n\n        /**\n         * LobbyInfo tables.\n         * @member {Array.<lobby.ITableInfo>} tables\n         * @memberof lobby.LobbyInfo\n         * @instance\n         */\n        LobbyInfo.prototype.tables = $util.emptyArray;\n\n        /**\n         * Creates a new LobbyInfo instance using the specified properties.\n         * @function create\n         * @memberof lobby.LobbyInfo\n         * @static\n         * @param {lobby.ILobbyInfo=} [properties] Properties to set\n         * @returns {lobby.LobbyInfo} LobbyInfo instance\n         */\n        LobbyInfo.create = function create(properties) {\n            return new LobbyInfo(properties);\n        };\n\n        /**\n         * Encodes the specified LobbyInfo message. Does not implicitly {@link lobby.LobbyInfo.verify|verify} messages.\n         * @function encode\n         * @memberof lobby.LobbyInfo\n         * @static\n         * @param {lobby.ILobbyInfo} message LobbyInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LobbyInfo.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.tables != null && message.tables.length)\n                for (let i = 0; i < message.tables.length; ++i)\n                    $root.lobby.TableInfo.encode(message.tables[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LobbyInfo message, length delimited. Does not implicitly {@link lobby.LobbyInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof lobby.LobbyInfo\n         * @static\n         * @param {lobby.ILobbyInfo} message LobbyInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LobbyInfo.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LobbyInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof lobby.LobbyInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {lobby.LobbyInfo} LobbyInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LobbyInfo.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lobby.LobbyInfo();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    if (!(message.tables && message.tables.length))\n                        message.tables = [];\n                    message.tables.push($root.lobby.TableInfo.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LobbyInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof lobby.LobbyInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {lobby.LobbyInfo} LobbyInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LobbyInfo.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LobbyInfo message.\n         * @function verify\n         * @memberof lobby.LobbyInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LobbyInfo.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.tables != null && message.hasOwnProperty(\"tables\")) {\n                if (!Array.isArray(message.tables))\n                    return \"tables: array expected\";\n                for (let i = 0; i < message.tables.length; ++i) {\n                    let error = $root.lobby.TableInfo.verify(message.tables[i]);\n                    if (error)\n                        return \"tables.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a LobbyInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof lobby.LobbyInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {lobby.LobbyInfo} LobbyInfo\n         */\n        LobbyInfo.fromObject = function fromObject(object) {\n            if (object instanceof $root.lobby.LobbyInfo)\n                return object;\n            let message = new $root.lobby.LobbyInfo();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".lobby.LobbyInfo.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.tables) {\n                if (!Array.isArray(object.tables))\n                    throw TypeError(\".lobby.LobbyInfo.tables: array expected\");\n                message.tables = [];\n                for (let i = 0; i < object.tables.length; ++i) {\n                    if (typeof object.tables[i] !== \"object\")\n                        throw TypeError(\".lobby.LobbyInfo.tables: object expected\");\n                    message.tables[i] = $root.lobby.TableInfo.fromObject(object.tables[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LobbyInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof lobby.LobbyInfo\n         * @static\n         * @param {lobby.LobbyInfo} message LobbyInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LobbyInfo.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.arrays || options.defaults)\n                object.tables = [];\n            if (options.defaults)\n                object.header = null;\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.tables && message.tables.length) {\n                object.tables = [];\n                for (let j = 0; j < message.tables.length; ++j)\n                    object.tables[j] = $root.lobby.TableInfo.toObject(message.tables[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this LobbyInfo to JSON.\n         * @function toJSON\n         * @memberof lobby.LobbyInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LobbyInfo.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LobbyInfo;\n    })();\n\n    lobby.TableInfo = (function() {\n\n        /**\n         * Properties of a TableInfo.\n         * @memberof lobby\n         * @interface ITableInfo\n         * @property {string|null} [uuid] TableInfo uuid\n         * @property {string|null} [name] TableInfo name\n         */\n\n        /**\n         * Constructs a new TableInfo.\n         * @memberof lobby\n         * @classdesc Represents a TableInfo.\n         * @implements ITableInfo\n         * @constructor\n         * @param {lobby.ITableInfo=} [properties] Properties to set\n         */\n        function TableInfo(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TableInfo uuid.\n         * @member {string} uuid\n         * @memberof lobby.TableInfo\n         * @instance\n         */\n        TableInfo.prototype.uuid = \"\";\n\n        /**\n         * TableInfo name.\n         * @member {string} name\n         * @memberof lobby.TableInfo\n         * @instance\n         */\n        TableInfo.prototype.name = \"\";\n\n        /**\n         * Creates a new TableInfo instance using the specified properties.\n         * @function create\n         * @memberof lobby.TableInfo\n         * @static\n         * @param {lobby.ITableInfo=} [properties] Properties to set\n         * @returns {lobby.TableInfo} TableInfo instance\n         */\n        TableInfo.create = function create(properties) {\n            return new TableInfo(properties);\n        };\n\n        /**\n         * Encodes the specified TableInfo message. Does not implicitly {@link lobby.TableInfo.verify|verify} messages.\n         * @function encode\n         * @memberof lobby.TableInfo\n         * @static\n         * @param {lobby.ITableInfo} message TableInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TableInfo.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.uuid != null && Object.hasOwnProperty.call(message, \"uuid\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.uuid);\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TableInfo message, length delimited. Does not implicitly {@link lobby.TableInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof lobby.TableInfo\n         * @static\n         * @param {lobby.ITableInfo} message TableInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TableInfo.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TableInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof lobby.TableInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {lobby.TableInfo} TableInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TableInfo.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lobby.TableInfo();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.uuid = reader.string();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TableInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof lobby.TableInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {lobby.TableInfo} TableInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TableInfo.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TableInfo message.\n         * @function verify\n         * @memberof lobby.TableInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TableInfo.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.uuid != null && message.hasOwnProperty(\"uuid\"))\n                if (!$util.isString(message.uuid))\n                    return \"uuid: string expected\";\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a TableInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof lobby.TableInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {lobby.TableInfo} TableInfo\n         */\n        TableInfo.fromObject = function fromObject(object) {\n            if (object instanceof $root.lobby.TableInfo)\n                return object;\n            let message = new $root.lobby.TableInfo();\n            if (object.uuid != null)\n                message.uuid = String(object.uuid);\n            if (object.name != null)\n                message.name = String(object.name);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TableInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof lobby.TableInfo\n         * @static\n         * @param {lobby.TableInfo} message TableInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TableInfo.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.uuid = \"\";\n                object.name = \"\";\n            }\n            if (message.uuid != null && message.hasOwnProperty(\"uuid\"))\n                object.uuid = message.uuid;\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            return object;\n        };\n\n        /**\n         * Converts this TableInfo to JSON.\n         * @function toJSON\n         * @memberof lobby.TableInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TableInfo.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return TableInfo;\n    })();\n\n    return lobby;\n})();\n\nexport const roadmap = $root.roadmap = (() => {\n\n    /**\n     * Namespace roadmap.\n     * @exports roadmap\n     * @namespace\n     */\n    const roadmap = {};\n\n    /**\n     * Block enum.\n     * @name roadmap.Block\n     * @enum {number}\n     * @property {number} BlockDefault=0 BlockDefault value\n     * @property {number} Banker=1 Banker value\n     * @property {number} Player=2 Player value\n     * @property {number} Tie=3 Tie value\n     * @property {number} BankerAndBankerPair=4 BankerAndBankerPair value\n     * @property {number} BankerAndPlayerPair=5 BankerAndPlayerPair value\n     * @property {number} BankerAndBothPair=6 BankerAndBothPair value\n     * @property {number} PlayerAndBankerPair=7 PlayerAndBankerPair value\n     * @property {number} PlayerAndPlayerPair=8 PlayerAndPlayerPair value\n     * @property {number} PlayerAndBothPair=9 PlayerAndBothPair value\n     * @property {number} TieAndBankerPair=10 TieAndBankerPair value\n     * @property {number} TieAndPlayerPair=11 TieAndPlayerPair value\n     * @property {number} TieAndBothPair=12 TieAndBothPair value\n     * @property {number} BankerAndTie=13 BankerAndTie value\n     * @property {number} BankerAndBankerPairAndTie=14 BankerAndBankerPairAndTie value\n     * @property {number} BankerAndPlayerPairAndTie=15 BankerAndPlayerPairAndTie value\n     * @property {number} BankerAndBothPairAndTie=16 BankerAndBothPairAndTie value\n     * @property {number} PlayerAndTie=17 PlayerAndTie value\n     * @property {number} PlayerAndBankerPairAndTie=18 PlayerAndBankerPairAndTie value\n     * @property {number} PlayerAndPlayerPairAndTie=19 PlayerAndPlayerPairAndTie value\n     * @property {number} PlayerAndBothPairAndTie=20 PlayerAndBothPairAndTie value\n     */\n    roadmap.Block = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"BlockDefault\"] = 0;\n        values[valuesById[1] = \"Banker\"] = 1;\n        values[valuesById[2] = \"Player\"] = 2;\n        values[valuesById[3] = \"Tie\"] = 3;\n        values[valuesById[4] = \"BankerAndBankerPair\"] = 4;\n        values[valuesById[5] = \"BankerAndPlayerPair\"] = 5;\n        values[valuesById[6] = \"BankerAndBothPair\"] = 6;\n        values[valuesById[7] = \"PlayerAndBankerPair\"] = 7;\n        values[valuesById[8] = \"PlayerAndPlayerPair\"] = 8;\n        values[valuesById[9] = \"PlayerAndBothPair\"] = 9;\n        values[valuesById[10] = \"TieAndBankerPair\"] = 10;\n        values[valuesById[11] = \"TieAndPlayerPair\"] = 11;\n        values[valuesById[12] = \"TieAndBothPair\"] = 12;\n        values[valuesById[13] = \"BankerAndTie\"] = 13;\n        values[valuesById[14] = \"BankerAndBankerPairAndTie\"] = 14;\n        values[valuesById[15] = \"BankerAndPlayerPairAndTie\"] = 15;\n        values[valuesById[16] = \"BankerAndBothPairAndTie\"] = 16;\n        values[valuesById[17] = \"PlayerAndTie\"] = 17;\n        values[valuesById[18] = \"PlayerAndBankerPairAndTie\"] = 18;\n        values[valuesById[19] = \"PlayerAndPlayerPairAndTie\"] = 19;\n        values[valuesById[20] = \"PlayerAndBothPairAndTie\"] = 20;\n        return values;\n    })();\n\n    roadmap.Column = (function() {\n\n        /**\n         * Properties of a Column.\n         * @memberof roadmap\n         * @interface IColumn\n         * @property {Array.<roadmap.Block>|null} [blocks] Column blocks\n         */\n\n        /**\n         * Constructs a new Column.\n         * @memberof roadmap\n         * @classdesc Represents a Column.\n         * @implements IColumn\n         * @constructor\n         * @param {roadmap.IColumn=} [properties] Properties to set\n         */\n        function Column(properties) {\n            this.blocks = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Column blocks.\n         * @member {Array.<roadmap.Block>} blocks\n         * @memberof roadmap.Column\n         * @instance\n         */\n        Column.prototype.blocks = $util.emptyArray;\n\n        /**\n         * Creates a new Column instance using the specified properties.\n         * @function create\n         * @memberof roadmap.Column\n         * @static\n         * @param {roadmap.IColumn=} [properties] Properties to set\n         * @returns {roadmap.Column} Column instance\n         */\n        Column.create = function create(properties) {\n            return new Column(properties);\n        };\n\n        /**\n         * Encodes the specified Column message. Does not implicitly {@link roadmap.Column.verify|verify} messages.\n         * @function encode\n         * @memberof roadmap.Column\n         * @static\n         * @param {roadmap.IColumn} message Column message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Column.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.blocks != null && message.blocks.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (let i = 0; i < message.blocks.length; ++i)\n                    writer.int32(message.blocks[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Column message, length delimited. Does not implicitly {@link roadmap.Column.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof roadmap.Column\n         * @static\n         * @param {roadmap.IColumn} message Column message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Column.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Column message from the specified reader or buffer.\n         * @function decode\n         * @memberof roadmap.Column\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {roadmap.Column} Column\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Column.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.roadmap.Column();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.blocks && message.blocks.length))\n                        message.blocks = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.blocks.push(reader.int32());\n                    } else\n                        message.blocks.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Column message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof roadmap.Column\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {roadmap.Column} Column\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Column.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Column message.\n         * @function verify\n         * @memberof roadmap.Column\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Column.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.blocks != null && message.hasOwnProperty(\"blocks\")) {\n                if (!Array.isArray(message.blocks))\n                    return \"blocks: array expected\";\n                for (let i = 0; i < message.blocks.length; ++i)\n                    switch (message.blocks[i]) {\n                    default:\n                        return \"blocks: enum value[] expected\";\n                    case 0:\n                    case 1:\n                    case 2:\n                    case 3:\n                    case 4:\n                    case 5:\n                    case 6:\n                    case 7:\n                    case 8:\n                    case 9:\n                    case 10:\n                    case 11:\n                    case 12:\n                    case 13:\n                    case 14:\n                    case 15:\n                    case 16:\n                    case 17:\n                    case 18:\n                    case 19:\n                    case 20:\n                        break;\n                    }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a Column message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof roadmap.Column\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {roadmap.Column} Column\n         */\n        Column.fromObject = function fromObject(object) {\n            if (object instanceof $root.roadmap.Column)\n                return object;\n            let message = new $root.roadmap.Column();\n            if (object.blocks) {\n                if (!Array.isArray(object.blocks))\n                    throw TypeError(\".roadmap.Column.blocks: array expected\");\n                message.blocks = [];\n                for (let i = 0; i < object.blocks.length; ++i)\n                    switch (object.blocks[i]) {\n                    default:\n                    case \"BlockDefault\":\n                    case 0:\n                        message.blocks[i] = 0;\n                        break;\n                    case \"Banker\":\n                    case 1:\n                        message.blocks[i] = 1;\n                        break;\n                    case \"Player\":\n                    case 2:\n                        message.blocks[i] = 2;\n                        break;\n                    case \"Tie\":\n                    case 3:\n                        message.blocks[i] = 3;\n                        break;\n                    case \"BankerAndBankerPair\":\n                    case 4:\n                        message.blocks[i] = 4;\n                        break;\n                    case \"BankerAndPlayerPair\":\n                    case 5:\n                        message.blocks[i] = 5;\n                        break;\n                    case \"BankerAndBothPair\":\n                    case 6:\n                        message.blocks[i] = 6;\n                        break;\n                    case \"PlayerAndBankerPair\":\n                    case 7:\n                        message.blocks[i] = 7;\n                        break;\n                    case \"PlayerAndPlayerPair\":\n                    case 8:\n                        message.blocks[i] = 8;\n                        break;\n                    case \"PlayerAndBothPair\":\n                    case 9:\n                        message.blocks[i] = 9;\n                        break;\n                    case \"TieAndBankerPair\":\n                    case 10:\n                        message.blocks[i] = 10;\n                        break;\n                    case \"TieAndPlayerPair\":\n                    case 11:\n                        message.blocks[i] = 11;\n                        break;\n                    case \"TieAndBothPair\":\n                    case 12:\n                        message.blocks[i] = 12;\n                        break;\n                    case \"BankerAndTie\":\n                    case 13:\n                        message.blocks[i] = 13;\n                        break;\n                    case \"BankerAndBankerPairAndTie\":\n                    case 14:\n                        message.blocks[i] = 14;\n                        break;\n                    case \"BankerAndPlayerPairAndTie\":\n                    case 15:\n                        message.blocks[i] = 15;\n                        break;\n                    case \"BankerAndBothPairAndTie\":\n                    case 16:\n                        message.blocks[i] = 16;\n                        break;\n                    case \"PlayerAndTie\":\n                    case 17:\n                        message.blocks[i] = 17;\n                        break;\n                    case \"PlayerAndBankerPairAndTie\":\n                    case 18:\n                        message.blocks[i] = 18;\n                        break;\n                    case \"PlayerAndPlayerPairAndTie\":\n                    case 19:\n                        message.blocks[i] = 19;\n                        break;\n                    case \"PlayerAndBothPairAndTie\":\n                    case 20:\n                        message.blocks[i] = 20;\n                        break;\n                    }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Column message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof roadmap.Column\n         * @static\n         * @param {roadmap.Column} message Column\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Column.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.arrays || options.defaults)\n                object.blocks = [];\n            if (message.blocks && message.blocks.length) {\n                object.blocks = [];\n                for (let j = 0; j < message.blocks.length; ++j)\n                    object.blocks[j] = options.enums === String ? $root.roadmap.Block[message.blocks[j]] : message.blocks[j];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this Column to JSON.\n         * @function toJSON\n         * @memberof roadmap.Column\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Column.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Column;\n    })();\n\n    roadmap.BeadPlate = (function() {\n\n        /**\n         * Properties of a BeadPlate.\n         * @memberof roadmap\n         * @interface IBeadPlate\n         * @property {Array.<roadmap.Block>|null} [blocks] BeadPlate blocks\n         */\n\n        /**\n         * Constructs a new BeadPlate.\n         * @memberof roadmap\n         * @classdesc Represents a BeadPlate.\n         * @implements IBeadPlate\n         * @constructor\n         * @param {roadmap.IBeadPlate=} [properties] Properties to set\n         */\n        function BeadPlate(properties) {\n            this.blocks = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BeadPlate blocks.\n         * @member {Array.<roadmap.Block>} blocks\n         * @memberof roadmap.BeadPlate\n         * @instance\n         */\n        BeadPlate.prototype.blocks = $util.emptyArray;\n\n        /**\n         * Creates a new BeadPlate instance using the specified properties.\n         * @function create\n         * @memberof roadmap.BeadPlate\n         * @static\n         * @param {roadmap.IBeadPlate=} [properties] Properties to set\n         * @returns {roadmap.BeadPlate} BeadPlate instance\n         */\n        BeadPlate.create = function create(properties) {\n            return new BeadPlate(properties);\n        };\n\n        /**\n         * Encodes the specified BeadPlate message. Does not implicitly {@link roadmap.BeadPlate.verify|verify} messages.\n         * @function encode\n         * @memberof roadmap.BeadPlate\n         * @static\n         * @param {roadmap.IBeadPlate} message BeadPlate message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BeadPlate.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.blocks != null && message.blocks.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (let i = 0; i < message.blocks.length; ++i)\n                    writer.int32(message.blocks[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BeadPlate message, length delimited. Does not implicitly {@link roadmap.BeadPlate.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof roadmap.BeadPlate\n         * @static\n         * @param {roadmap.IBeadPlate} message BeadPlate message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BeadPlate.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BeadPlate message from the specified reader or buffer.\n         * @function decode\n         * @memberof roadmap.BeadPlate\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {roadmap.BeadPlate} BeadPlate\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BeadPlate.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.roadmap.BeadPlate();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.blocks && message.blocks.length))\n                        message.blocks = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.blocks.push(reader.int32());\n                    } else\n                        message.blocks.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BeadPlate message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof roadmap.BeadPlate\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {roadmap.BeadPlate} BeadPlate\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BeadPlate.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BeadPlate message.\n         * @function verify\n         * @memberof roadmap.BeadPlate\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BeadPlate.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.blocks != null && message.hasOwnProperty(\"blocks\")) {\n                if (!Array.isArray(message.blocks))\n                    return \"blocks: array expected\";\n                for (let i = 0; i < message.blocks.length; ++i)\n                    switch (message.blocks[i]) {\n                    default:\n                        return \"blocks: enum value[] expected\";\n                    case 0:\n                    case 1:\n                    case 2:\n                    case 3:\n                    case 4:\n                    case 5:\n                    case 6:\n                    case 7:\n                    case 8:\n                    case 9:\n                    case 10:\n                    case 11:\n                    case 12:\n                    case 13:\n                    case 14:\n                    case 15:\n                    case 16:\n                    case 17:\n                    case 18:\n                    case 19:\n                    case 20:\n                        break;\n                    }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BeadPlate message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof roadmap.BeadPlate\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {roadmap.BeadPlate} BeadPlate\n         */\n        BeadPlate.fromObject = function fromObject(object) {\n            if (object instanceof $root.roadmap.BeadPlate)\n                return object;\n            let message = new $root.roadmap.BeadPlate();\n            if (object.blocks) {\n                if (!Array.isArray(object.blocks))\n                    throw TypeError(\".roadmap.BeadPlate.blocks: array expected\");\n                message.blocks = [];\n                for (let i = 0; i < object.blocks.length; ++i)\n                    switch (object.blocks[i]) {\n                    default:\n                    case \"BlockDefault\":\n                    case 0:\n                        message.blocks[i] = 0;\n                        break;\n                    case \"Banker\":\n                    case 1:\n                        message.blocks[i] = 1;\n                        break;\n                    case \"Player\":\n                    case 2:\n                        message.blocks[i] = 2;\n                        break;\n                    case \"Tie\":\n                    case 3:\n                        message.blocks[i] = 3;\n                        break;\n                    case \"BankerAndBankerPair\":\n                    case 4:\n                        message.blocks[i] = 4;\n                        break;\n                    case \"BankerAndPlayerPair\":\n                    case 5:\n                        message.blocks[i] = 5;\n                        break;\n                    case \"BankerAndBothPair\":\n                    case 6:\n                        message.blocks[i] = 6;\n                        break;\n                    case \"PlayerAndBankerPair\":\n                    case 7:\n                        message.blocks[i] = 7;\n                        break;\n                    case \"PlayerAndPlayerPair\":\n                    case 8:\n                        message.blocks[i] = 8;\n                        break;\n                    case \"PlayerAndBothPair\":\n                    case 9:\n                        message.blocks[i] = 9;\n                        break;\n                    case \"TieAndBankerPair\":\n                    case 10:\n                        message.blocks[i] = 10;\n                        break;\n                    case \"TieAndPlayerPair\":\n                    case 11:\n                        message.blocks[i] = 11;\n                        break;\n                    case \"TieAndBothPair\":\n                    case 12:\n                        message.blocks[i] = 12;\n                        break;\n                    case \"BankerAndTie\":\n                    case 13:\n                        message.blocks[i] = 13;\n                        break;\n                    case \"BankerAndBankerPairAndTie\":\n                    case 14:\n                        message.blocks[i] = 14;\n                        break;\n                    case \"BankerAndPlayerPairAndTie\":\n                    case 15:\n                        message.blocks[i] = 15;\n                        break;\n                    case \"BankerAndBothPairAndTie\":\n                    case 16:\n                        message.blocks[i] = 16;\n                        break;\n                    case \"PlayerAndTie\":\n                    case 17:\n                        message.blocks[i] = 17;\n                        break;\n                    case \"PlayerAndBankerPairAndTie\":\n                    case 18:\n                        message.blocks[i] = 18;\n                        break;\n                    case \"PlayerAndPlayerPairAndTie\":\n                    case 19:\n                        message.blocks[i] = 19;\n                        break;\n                    case \"PlayerAndBothPairAndTie\":\n                    case 20:\n                        message.blocks[i] = 20;\n                        break;\n                    }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BeadPlate message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof roadmap.BeadPlate\n         * @static\n         * @param {roadmap.BeadPlate} message BeadPlate\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BeadPlate.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.arrays || options.defaults)\n                object.blocks = [];\n            if (message.blocks && message.blocks.length) {\n                object.blocks = [];\n                for (let j = 0; j < message.blocks.length; ++j)\n                    object.blocks[j] = options.enums === String ? $root.roadmap.Block[message.blocks[j]] : message.blocks[j];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BeadPlate to JSON.\n         * @function toJSON\n         * @memberof roadmap.BeadPlate\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BeadPlate.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BeadPlate;\n    })();\n\n    roadmap.BigRoad = (function() {\n\n        /**\n         * Properties of a BigRoad.\n         * @memberof roadmap\n         * @interface IBigRoad\n         * @property {Array.<roadmap.IColumn>|null} [columns] BigRoad columns\n         */\n\n        /**\n         * Constructs a new BigRoad.\n         * @memberof roadmap\n         * @classdesc Represents a BigRoad.\n         * @implements IBigRoad\n         * @constructor\n         * @param {roadmap.IBigRoad=} [properties] Properties to set\n         */\n        function BigRoad(properties) {\n            this.columns = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BigRoad columns.\n         * @member {Array.<roadmap.IColumn>} columns\n         * @memberof roadmap.BigRoad\n         * @instance\n         */\n        BigRoad.prototype.columns = $util.emptyArray;\n\n        /**\n         * Creates a new BigRoad instance using the specified properties.\n         * @function create\n         * @memberof roadmap.BigRoad\n         * @static\n         * @param {roadmap.IBigRoad=} [properties] Properties to set\n         * @returns {roadmap.BigRoad} BigRoad instance\n         */\n        BigRoad.create = function create(properties) {\n            return new BigRoad(properties);\n        };\n\n        /**\n         * Encodes the specified BigRoad message. Does not implicitly {@link roadmap.BigRoad.verify|verify} messages.\n         * @function encode\n         * @memberof roadmap.BigRoad\n         * @static\n         * @param {roadmap.IBigRoad} message BigRoad message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BigRoad.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.columns != null && message.columns.length)\n                for (let i = 0; i < message.columns.length; ++i)\n                    $root.roadmap.Column.encode(message.columns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BigRoad message, length delimited. Does not implicitly {@link roadmap.BigRoad.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof roadmap.BigRoad\n         * @static\n         * @param {roadmap.IBigRoad} message BigRoad message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BigRoad.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BigRoad message from the specified reader or buffer.\n         * @function decode\n         * @memberof roadmap.BigRoad\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {roadmap.BigRoad} BigRoad\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BigRoad.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.roadmap.BigRoad();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.columns && message.columns.length))\n                        message.columns = [];\n                    message.columns.push($root.roadmap.Column.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BigRoad message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof roadmap.BigRoad\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {roadmap.BigRoad} BigRoad\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BigRoad.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BigRoad message.\n         * @function verify\n         * @memberof roadmap.BigRoad\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BigRoad.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.columns != null && message.hasOwnProperty(\"columns\")) {\n                if (!Array.isArray(message.columns))\n                    return \"columns: array expected\";\n                for (let i = 0; i < message.columns.length; ++i) {\n                    let error = $root.roadmap.Column.verify(message.columns[i]);\n                    if (error)\n                        return \"columns.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BigRoad message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof roadmap.BigRoad\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {roadmap.BigRoad} BigRoad\n         */\n        BigRoad.fromObject = function fromObject(object) {\n            if (object instanceof $root.roadmap.BigRoad)\n                return object;\n            let message = new $root.roadmap.BigRoad();\n            if (object.columns) {\n                if (!Array.isArray(object.columns))\n                    throw TypeError(\".roadmap.BigRoad.columns: array expected\");\n                message.columns = [];\n                for (let i = 0; i < object.columns.length; ++i) {\n                    if (typeof object.columns[i] !== \"object\")\n                        throw TypeError(\".roadmap.BigRoad.columns: object expected\");\n                    message.columns[i] = $root.roadmap.Column.fromObject(object.columns[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BigRoad message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof roadmap.BigRoad\n         * @static\n         * @param {roadmap.BigRoad} message BigRoad\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BigRoad.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.arrays || options.defaults)\n                object.columns = [];\n            if (message.columns && message.columns.length) {\n                object.columns = [];\n                for (let j = 0; j < message.columns.length; ++j)\n                    object.columns[j] = $root.roadmap.Column.toObject(message.columns[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BigRoad to JSON.\n         * @function toJSON\n         * @memberof roadmap.BigRoad\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BigRoad.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BigRoad;\n    })();\n\n    roadmap.Roadmap = (function() {\n\n        /**\n         * Properties of a Roadmap.\n         * @memberof roadmap\n         * @interface IRoadmap\n         * @property {foundation.IHeader|null} [header] Roadmap header\n         * @property {roadmap.IBeadPlate|null} [beadPlate] Roadmap beadPlate\n         * @property {roadmap.IBigRoad|null} [bigRoad] Roadmap bigRoad\n         */\n\n        /**\n         * Constructs a new Roadmap.\n         * @memberof roadmap\n         * @classdesc Represents a Roadmap.\n         * @implements IRoadmap\n         * @constructor\n         * @param {roadmap.IRoadmap=} [properties] Properties to set\n         */\n        function Roadmap(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Roadmap header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof roadmap.Roadmap\n         * @instance\n         */\n        Roadmap.prototype.header = null;\n\n        /**\n         * Roadmap beadPlate.\n         * @member {roadmap.IBeadPlate|null|undefined} beadPlate\n         * @memberof roadmap.Roadmap\n         * @instance\n         */\n        Roadmap.prototype.beadPlate = null;\n\n        /**\n         * Roadmap bigRoad.\n         * @member {roadmap.IBigRoad|null|undefined} bigRoad\n         * @memberof roadmap.Roadmap\n         * @instance\n         */\n        Roadmap.prototype.bigRoad = null;\n\n        /**\n         * Creates a new Roadmap instance using the specified properties.\n         * @function create\n         * @memberof roadmap.Roadmap\n         * @static\n         * @param {roadmap.IRoadmap=} [properties] Properties to set\n         * @returns {roadmap.Roadmap} Roadmap instance\n         */\n        Roadmap.create = function create(properties) {\n            return new Roadmap(properties);\n        };\n\n        /**\n         * Encodes the specified Roadmap message. Does not implicitly {@link roadmap.Roadmap.verify|verify} messages.\n         * @function encode\n         * @memberof roadmap.Roadmap\n         * @static\n         * @param {roadmap.IRoadmap} message Roadmap message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Roadmap.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.beadPlate != null && Object.hasOwnProperty.call(message, \"beadPlate\"))\n                $root.roadmap.BeadPlate.encode(message.beadPlate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.bigRoad != null && Object.hasOwnProperty.call(message, \"bigRoad\"))\n                $root.roadmap.BigRoad.encode(message.bigRoad, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Roadmap message, length delimited. Does not implicitly {@link roadmap.Roadmap.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof roadmap.Roadmap\n         * @static\n         * @param {roadmap.IRoadmap} message Roadmap message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Roadmap.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Roadmap message from the specified reader or buffer.\n         * @function decode\n         * @memberof roadmap.Roadmap\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {roadmap.Roadmap} Roadmap\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Roadmap.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.roadmap.Roadmap();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.beadPlate = $root.roadmap.BeadPlate.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.bigRoad = $root.roadmap.BigRoad.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Roadmap message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof roadmap.Roadmap\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {roadmap.Roadmap} Roadmap\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Roadmap.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Roadmap message.\n         * @function verify\n         * @memberof roadmap.Roadmap\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Roadmap.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.beadPlate != null && message.hasOwnProperty(\"beadPlate\")) {\n                let error = $root.roadmap.BeadPlate.verify(message.beadPlate);\n                if (error)\n                    return \"beadPlate.\" + error;\n            }\n            if (message.bigRoad != null && message.hasOwnProperty(\"bigRoad\")) {\n                let error = $root.roadmap.BigRoad.verify(message.bigRoad);\n                if (error)\n                    return \"bigRoad.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a Roadmap message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof roadmap.Roadmap\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {roadmap.Roadmap} Roadmap\n         */\n        Roadmap.fromObject = function fromObject(object) {\n            if (object instanceof $root.roadmap.Roadmap)\n                return object;\n            let message = new $root.roadmap.Roadmap();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".roadmap.Roadmap.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.beadPlate != null) {\n                if (typeof object.beadPlate !== \"object\")\n                    throw TypeError(\".roadmap.Roadmap.beadPlate: object expected\");\n                message.beadPlate = $root.roadmap.BeadPlate.fromObject(object.beadPlate);\n            }\n            if (object.bigRoad != null) {\n                if (typeof object.bigRoad !== \"object\")\n                    throw TypeError(\".roadmap.Roadmap.bigRoad: object expected\");\n                message.bigRoad = $root.roadmap.BigRoad.fromObject(object.bigRoad);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Roadmap message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof roadmap.Roadmap\n         * @static\n         * @param {roadmap.Roadmap} message Roadmap\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Roadmap.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.beadPlate = null;\n                object.bigRoad = null;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.beadPlate != null && message.hasOwnProperty(\"beadPlate\"))\n                object.beadPlate = $root.roadmap.BeadPlate.toObject(message.beadPlate, options);\n            if (message.bigRoad != null && message.hasOwnProperty(\"bigRoad\"))\n                object.bigRoad = $root.roadmap.BigRoad.toObject(message.bigRoad, options);\n            return object;\n        };\n\n        /**\n         * Converts this Roadmap to JSON.\n         * @function toJSON\n         * @memberof roadmap.Roadmap\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Roadmap.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Roadmap;\n    })();\n\n    return roadmap;\n})();\n\nexport const route = $root.route = (() => {\n\n    /**\n     * Namespace route.\n     * @exports route\n     * @namespace\n     */\n    const route = {};\n\n    /**\n     * URI enum.\n     * @name route.URI\n     * @enum {number}\n     * @property {number} Default=0 Default value\n     * @property {number} LoginCall=1 LoginCall value\n     * @property {number} LoginRecall=2 LoginRecall value\n     * @property {number} LobbyInfo=3 LobbyInfo value\n     * @property {number} UserInfo=4 UserInfo value\n     * @property {number} TableJoinCall=5 TableJoinCall value\n     * @property {number} TableJoinRecall=6 TableJoinRecall value\n     * @property {number} BetCall=7 BetCall value\n     * @property {number} BetRecall=8 BetRecall value\n     * @property {number} BetResetCall=9 BetResetCall value\n     * @property {number} BetResetRecall=10 BetResetRecall value\n     * @property {number} Draw=11 Draw value\n     * @property {number} DealerGameResult=12 DealerGameResult value\n     * @property {number} BroadcastGameResult=13 BroadcastGameResult value\n     * @property {number} BetRoundStart=14 BetRoundStart value\n     * @property {number} BetRoundEnd=15 BetRoundEnd value\n     * @property {number} BetRoundCountdown=16 BetRoundCountdown value\n     * @property {number} HeartbeatPing=17 HeartbeatPing value\n     * @property {number} HeartbeatPong=18 HeartbeatPong value\n     * @property {number} DealerRoundStartCall=19 DealerRoundStartCall value\n     * @property {number} DealerRoundStartRecall=20 DealerRoundStartRecall value\n     * @property {number} DealerRoundEndCall=21 DealerRoundEndCall value\n     * @property {number} DealerRoundEndRecall=22 DealerRoundEndRecall value\n     * @property {number} BroadcastDealerRoundEnd=220 BroadcastDealerRoundEnd value\n     * @property {number} BetError=23 BetError value\n     * @property {number} GameStatus=24 GameStatus value\n     * @property {number} DealerGameStatus=25 DealerGameStatus value\n     * @property {number} Roadmap=26 Roadmap value\n     */\n    route.URI = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Default\"] = 0;\n        values[valuesById[1] = \"LoginCall\"] = 1;\n        values[valuesById[2] = \"LoginRecall\"] = 2;\n        values[valuesById[3] = \"LobbyInfo\"] = 3;\n        values[valuesById[4] = \"UserInfo\"] = 4;\n        values[valuesById[5] = \"TableJoinCall\"] = 5;\n        values[valuesById[6] = \"TableJoinRecall\"] = 6;\n        values[valuesById[7] = \"BetCall\"] = 7;\n        values[valuesById[8] = \"BetRecall\"] = 8;\n        values[valuesById[9] = \"BetResetCall\"] = 9;\n        values[valuesById[10] = \"BetResetRecall\"] = 10;\n        values[valuesById[11] = \"Draw\"] = 11;\n        values[valuesById[12] = \"DealerGameResult\"] = 12;\n        values[valuesById[13] = \"BroadcastGameResult\"] = 13;\n        values[valuesById[14] = \"BetRoundStart\"] = 14;\n        values[valuesById[15] = \"BetRoundEnd\"] = 15;\n        values[valuesById[16] = \"BetRoundCountdown\"] = 16;\n        values[valuesById[17] = \"HeartbeatPing\"] = 17;\n        values[valuesById[18] = \"HeartbeatPong\"] = 18;\n        values[valuesById[19] = \"DealerRoundStartCall\"] = 19;\n        values[valuesById[20] = \"DealerRoundStartRecall\"] = 20;\n        values[valuesById[21] = \"DealerRoundEndCall\"] = 21;\n        values[valuesById[22] = \"DealerRoundEndRecall\"] = 22;\n        values[valuesById[220] = \"BroadcastDealerRoundEnd\"] = 220;\n        values[valuesById[23] = \"BetError\"] = 23;\n        values[valuesById[24] = \"GameStatus\"] = 24;\n        values[valuesById[25] = \"DealerGameStatus\"] = 25;\n        values[valuesById[26] = \"Roadmap\"] = 26;\n        return values;\n    })();\n\n    return route;\n})();\n\nexport const table = $root.table = (() => {\n\n    /**\n     * Namespace table.\n     * @exports table\n     * @namespace\n     */\n    const table = {};\n\n    table.Table = (function() {\n\n        /**\n         * Properties of a Table.\n         * @memberof table\n         * @interface ITable\n         * @property {table.IBetStatus|null} [betStatus] Table betStatus\n         * @property {string|null} [streamingUrl] Table streamingUrl\n         */\n\n        /**\n         * Constructs a new Table.\n         * @memberof table\n         * @classdesc Represents a Table.\n         * @implements ITable\n         * @constructor\n         * @param {table.ITable=} [properties] Properties to set\n         */\n        function Table(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Table betStatus.\n         * @member {table.IBetStatus|null|undefined} betStatus\n         * @memberof table.Table\n         * @instance\n         */\n        Table.prototype.betStatus = null;\n\n        /**\n         * Table streamingUrl.\n         * @member {string} streamingUrl\n         * @memberof table.Table\n         * @instance\n         */\n        Table.prototype.streamingUrl = \"\";\n\n        /**\n         * Creates a new Table instance using the specified properties.\n         * @function create\n         * @memberof table.Table\n         * @static\n         * @param {table.ITable=} [properties] Properties to set\n         * @returns {table.Table} Table instance\n         */\n        Table.create = function create(properties) {\n            return new Table(properties);\n        };\n\n        /**\n         * Encodes the specified Table message. Does not implicitly {@link table.Table.verify|verify} messages.\n         * @function encode\n         * @memberof table.Table\n         * @static\n         * @param {table.ITable} message Table message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Table.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.betStatus != null && Object.hasOwnProperty.call(message, \"betStatus\"))\n                $root.table.BetStatus.encode(message.betStatus, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.streamingUrl != null && Object.hasOwnProperty.call(message, \"streamingUrl\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.streamingUrl);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Table message, length delimited. Does not implicitly {@link table.Table.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof table.Table\n         * @static\n         * @param {table.ITable} message Table message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Table.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Table message from the specified reader or buffer.\n         * @function decode\n         * @memberof table.Table\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {table.Table} Table\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Table.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.table.Table();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.betStatus = $root.table.BetStatus.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.streamingUrl = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Table message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof table.Table\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {table.Table} Table\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Table.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Table message.\n         * @function verify\n         * @memberof table.Table\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Table.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.betStatus != null && message.hasOwnProperty(\"betStatus\")) {\n                let error = $root.table.BetStatus.verify(message.betStatus);\n                if (error)\n                    return \"betStatus.\" + error;\n            }\n            if (message.streamingUrl != null && message.hasOwnProperty(\"streamingUrl\"))\n                if (!$util.isString(message.streamingUrl))\n                    return \"streamingUrl: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a Table message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof table.Table\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {table.Table} Table\n         */\n        Table.fromObject = function fromObject(object) {\n            if (object instanceof $root.table.Table)\n                return object;\n            let message = new $root.table.Table();\n            if (object.betStatus != null) {\n                if (typeof object.betStatus !== \"object\")\n                    throw TypeError(\".table.Table.betStatus: object expected\");\n                message.betStatus = $root.table.BetStatus.fromObject(object.betStatus);\n            }\n            if (object.streamingUrl != null)\n                message.streamingUrl = String(object.streamingUrl);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Table message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof table.Table\n         * @static\n         * @param {table.Table} message Table\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Table.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.betStatus = null;\n                object.streamingUrl = \"\";\n            }\n            if (message.betStatus != null && message.hasOwnProperty(\"betStatus\"))\n                object.betStatus = $root.table.BetStatus.toObject(message.betStatus, options);\n            if (message.streamingUrl != null && message.hasOwnProperty(\"streamingUrl\"))\n                object.streamingUrl = message.streamingUrl;\n            return object;\n        };\n\n        /**\n         * Converts this Table to JSON.\n         * @function toJSON\n         * @memberof table.Table\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Table.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Table;\n    })();\n\n    table.TableJoinCall = (function() {\n\n        /**\n         * Properties of a TableJoinCall.\n         * @memberof table\n         * @interface ITableJoinCall\n         * @property {foundation.IHeader|null} [header] TableJoinCall header\n         * @property {string|null} [uuid] TableJoinCall uuid\n         */\n\n        /**\n         * Constructs a new TableJoinCall.\n         * @memberof table\n         * @classdesc Represents a TableJoinCall.\n         * @implements ITableJoinCall\n         * @constructor\n         * @param {table.ITableJoinCall=} [properties] Properties to set\n         */\n        function TableJoinCall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TableJoinCall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof table.TableJoinCall\n         * @instance\n         */\n        TableJoinCall.prototype.header = null;\n\n        /**\n         * TableJoinCall uuid.\n         * @member {string} uuid\n         * @memberof table.TableJoinCall\n         * @instance\n         */\n        TableJoinCall.prototype.uuid = \"\";\n\n        /**\n         * Creates a new TableJoinCall instance using the specified properties.\n         * @function create\n         * @memberof table.TableJoinCall\n         * @static\n         * @param {table.ITableJoinCall=} [properties] Properties to set\n         * @returns {table.TableJoinCall} TableJoinCall instance\n         */\n        TableJoinCall.create = function create(properties) {\n            return new TableJoinCall(properties);\n        };\n\n        /**\n         * Encodes the specified TableJoinCall message. Does not implicitly {@link table.TableJoinCall.verify|verify} messages.\n         * @function encode\n         * @memberof table.TableJoinCall\n         * @static\n         * @param {table.ITableJoinCall} message TableJoinCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TableJoinCall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.uuid != null && Object.hasOwnProperty.call(message, \"uuid\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.uuid);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TableJoinCall message, length delimited. Does not implicitly {@link table.TableJoinCall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof table.TableJoinCall\n         * @static\n         * @param {table.ITableJoinCall} message TableJoinCall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TableJoinCall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TableJoinCall message from the specified reader or buffer.\n         * @function decode\n         * @memberof table.TableJoinCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {table.TableJoinCall} TableJoinCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TableJoinCall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.table.TableJoinCall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.uuid = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TableJoinCall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof table.TableJoinCall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {table.TableJoinCall} TableJoinCall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TableJoinCall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TableJoinCall message.\n         * @function verify\n         * @memberof table.TableJoinCall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TableJoinCall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.uuid != null && message.hasOwnProperty(\"uuid\"))\n                if (!$util.isString(message.uuid))\n                    return \"uuid: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a TableJoinCall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof table.TableJoinCall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {table.TableJoinCall} TableJoinCall\n         */\n        TableJoinCall.fromObject = function fromObject(object) {\n            if (object instanceof $root.table.TableJoinCall)\n                return object;\n            let message = new $root.table.TableJoinCall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".table.TableJoinCall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.uuid != null)\n                message.uuid = String(object.uuid);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TableJoinCall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof table.TableJoinCall\n         * @static\n         * @param {table.TableJoinCall} message TableJoinCall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TableJoinCall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.uuid = \"\";\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.uuid != null && message.hasOwnProperty(\"uuid\"))\n                object.uuid = message.uuid;\n            return object;\n        };\n\n        /**\n         * Converts this TableJoinCall to JSON.\n         * @function toJSON\n         * @memberof table.TableJoinCall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TableJoinCall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return TableJoinCall;\n    })();\n\n    table.TableJoinRecall = (function() {\n\n        /**\n         * Properties of a TableJoinRecall.\n         * @memberof table\n         * @interface ITableJoinRecall\n         * @property {foundation.IHeader|null} [header] TableJoinRecall header\n         * @property {table.ITable|null} [table] TableJoinRecall table\n         */\n\n        /**\n         * Constructs a new TableJoinRecall.\n         * @memberof table\n         * @classdesc Represents a TableJoinRecall.\n         * @implements ITableJoinRecall\n         * @constructor\n         * @param {table.ITableJoinRecall=} [properties] Properties to set\n         */\n        function TableJoinRecall(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TableJoinRecall header.\n         * @member {foundation.IHeader|null|undefined} header\n         * @memberof table.TableJoinRecall\n         * @instance\n         */\n        TableJoinRecall.prototype.header = null;\n\n        /**\n         * TableJoinRecall table.\n         * @member {table.ITable|null|undefined} table\n         * @memberof table.TableJoinRecall\n         * @instance\n         */\n        TableJoinRecall.prototype.table = null;\n\n        /**\n         * Creates a new TableJoinRecall instance using the specified properties.\n         * @function create\n         * @memberof table.TableJoinRecall\n         * @static\n         * @param {table.ITableJoinRecall=} [properties] Properties to set\n         * @returns {table.TableJoinRecall} TableJoinRecall instance\n         */\n        TableJoinRecall.create = function create(properties) {\n            return new TableJoinRecall(properties);\n        };\n\n        /**\n         * Encodes the specified TableJoinRecall message. Does not implicitly {@link table.TableJoinRecall.verify|verify} messages.\n         * @function encode\n         * @memberof table.TableJoinRecall\n         * @static\n         * @param {table.ITableJoinRecall} message TableJoinRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TableJoinRecall.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n                $root.foundation.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.table != null && Object.hasOwnProperty.call(message, \"table\"))\n                $root.table.Table.encode(message.table, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TableJoinRecall message, length delimited. Does not implicitly {@link table.TableJoinRecall.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof table.TableJoinRecall\n         * @static\n         * @param {table.ITableJoinRecall} message TableJoinRecall message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TableJoinRecall.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TableJoinRecall message from the specified reader or buffer.\n         * @function decode\n         * @memberof table.TableJoinRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {table.TableJoinRecall} TableJoinRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TableJoinRecall.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.table.TableJoinRecall();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.header = $root.foundation.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.table = $root.table.Table.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TableJoinRecall message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof table.TableJoinRecall\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {table.TableJoinRecall} TableJoinRecall\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TableJoinRecall.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TableJoinRecall message.\n         * @function verify\n         * @memberof table.TableJoinRecall\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TableJoinRecall.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.header != null && message.hasOwnProperty(\"header\")) {\n                let error = $root.foundation.Header.verify(message.header);\n                if (error)\n                    return \"header.\" + error;\n            }\n            if (message.table != null && message.hasOwnProperty(\"table\")) {\n                let error = $root.table.Table.verify(message.table);\n                if (error)\n                    return \"table.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a TableJoinRecall message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof table.TableJoinRecall\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {table.TableJoinRecall} TableJoinRecall\n         */\n        TableJoinRecall.fromObject = function fromObject(object) {\n            if (object instanceof $root.table.TableJoinRecall)\n                return object;\n            let message = new $root.table.TableJoinRecall();\n            if (object.header != null) {\n                if (typeof object.header !== \"object\")\n                    throw TypeError(\".table.TableJoinRecall.header: object expected\");\n                message.header = $root.foundation.Header.fromObject(object.header);\n            }\n            if (object.table != null) {\n                if (typeof object.table !== \"object\")\n                    throw TypeError(\".table.TableJoinRecall.table: object expected\");\n                message.table = $root.table.Table.fromObject(object.table);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TableJoinRecall message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof table.TableJoinRecall\n         * @static\n         * @param {table.TableJoinRecall} message TableJoinRecall\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TableJoinRecall.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.header = null;\n                object.table = null;\n            }\n            if (message.header != null && message.hasOwnProperty(\"header\"))\n                object.header = $root.foundation.Header.toObject(message.header, options);\n            if (message.table != null && message.hasOwnProperty(\"table\"))\n                object.table = $root.table.Table.toObject(message.table, options);\n            return object;\n        };\n\n        /**\n         * Converts this TableJoinRecall to JSON.\n         * @function toJSON\n         * @memberof table.TableJoinRecall\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TableJoinRecall.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return TableJoinRecall;\n    })();\n\n    table.BetStatus = (function() {\n\n        /**\n         * Properties of a BetStatus.\n         * @memberof table\n         * @interface IBetStatus\n         * @property {string|null} [Banker] BetStatus Banker\n         * @property {string|null} [Player] BetStatus Player\n         * @property {string|null} [Tie] BetStatus Tie\n         * @property {string|null} [BankerPair] BetStatus BankerPair\n         * @property {string|null} [PlayerPair] BetStatus PlayerPair\n         * @property {string|null} [BankerNatural] BetStatus BankerNatural\n         * @property {string|null} [PlayerNatural] BetStatus PlayerNatural\n         */\n\n        /**\n         * Constructs a new BetStatus.\n         * @memberof table\n         * @classdesc Represents a BetStatus.\n         * @implements IBetStatus\n         * @constructor\n         * @param {table.IBetStatus=} [properties] Properties to set\n         */\n        function BetStatus(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BetStatus Banker.\n         * @member {string} Banker\n         * @memberof table.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.Banker = \"\";\n\n        /**\n         * BetStatus Player.\n         * @member {string} Player\n         * @memberof table.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.Player = \"\";\n\n        /**\n         * BetStatus Tie.\n         * @member {string} Tie\n         * @memberof table.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.Tie = \"\";\n\n        /**\n         * BetStatus BankerPair.\n         * @member {string} BankerPair\n         * @memberof table.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.BankerPair = \"\";\n\n        /**\n         * BetStatus PlayerPair.\n         * @member {string} PlayerPair\n         * @memberof table.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.PlayerPair = \"\";\n\n        /**\n         * BetStatus BankerNatural.\n         * @member {string} BankerNatural\n         * @memberof table.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.BankerNatural = \"\";\n\n        /**\n         * BetStatus PlayerNatural.\n         * @member {string} PlayerNatural\n         * @memberof table.BetStatus\n         * @instance\n         */\n        BetStatus.prototype.PlayerNatural = \"\";\n\n        /**\n         * Creates a new BetStatus instance using the specified properties.\n         * @function create\n         * @memberof table.BetStatus\n         * @static\n         * @param {table.IBetStatus=} [properties] Properties to set\n         * @returns {table.BetStatus} BetStatus instance\n         */\n        BetStatus.create = function create(properties) {\n            return new BetStatus(properties);\n        };\n\n        /**\n         * Encodes the specified BetStatus message. Does not implicitly {@link table.BetStatus.verify|verify} messages.\n         * @function encode\n         * @memberof table.BetStatus\n         * @static\n         * @param {table.IBetStatus} message BetStatus message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetStatus.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.Banker != null && Object.hasOwnProperty.call(message, \"Banker\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Banker);\n            if (message.Player != null && Object.hasOwnProperty.call(message, \"Player\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Player);\n            if (message.Tie != null && Object.hasOwnProperty.call(message, \"Tie\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Tie);\n            if (message.BankerPair != null && Object.hasOwnProperty.call(message, \"BankerPair\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.BankerPair);\n            if (message.PlayerPair != null && Object.hasOwnProperty.call(message, \"PlayerPair\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).string(message.PlayerPair);\n            if (message.BankerNatural != null && Object.hasOwnProperty.call(message, \"BankerNatural\"))\n                writer.uint32(/* id 6, wireType 2 =*/50).string(message.BankerNatural);\n            if (message.PlayerNatural != null && Object.hasOwnProperty.call(message, \"PlayerNatural\"))\n                writer.uint32(/* id 7, wireType 2 =*/58).string(message.PlayerNatural);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BetStatus message, length delimited. Does not implicitly {@link table.BetStatus.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof table.BetStatus\n         * @static\n         * @param {table.IBetStatus} message BetStatus message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BetStatus.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BetStatus message from the specified reader or buffer.\n         * @function decode\n         * @memberof table.BetStatus\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {table.BetStatus} BetStatus\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetStatus.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.table.BetStatus();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.Banker = reader.string();\n                    break;\n                case 2:\n                    message.Player = reader.string();\n                    break;\n                case 3:\n                    message.Tie = reader.string();\n                    break;\n                case 4:\n                    message.BankerPair = reader.string();\n                    break;\n                case 5:\n                    message.PlayerPair = reader.string();\n                    break;\n                case 6:\n                    message.BankerNatural = reader.string();\n                    break;\n                case 7:\n                    message.PlayerNatural = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BetStatus message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof table.BetStatus\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {table.BetStatus} BetStatus\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BetStatus.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BetStatus message.\n         * @function verify\n         * @memberof table.BetStatus\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BetStatus.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.Banker != null && message.hasOwnProperty(\"Banker\"))\n                if (!$util.isString(message.Banker))\n                    return \"Banker: string expected\";\n            if (message.Player != null && message.hasOwnProperty(\"Player\"))\n                if (!$util.isString(message.Player))\n                    return \"Player: string expected\";\n            if (message.Tie != null && message.hasOwnProperty(\"Tie\"))\n                if (!$util.isString(message.Tie))\n                    return \"Tie: string expected\";\n            if (message.BankerPair != null && message.hasOwnProperty(\"BankerPair\"))\n                if (!$util.isString(message.BankerPair))\n                    return \"BankerPair: string expected\";\n            if (message.PlayerPair != null && message.hasOwnProperty(\"PlayerPair\"))\n                if (!$util.isString(message.PlayerPair))\n                    return \"PlayerPair: string expected\";\n            if (message.BankerNatural != null && message.hasOwnProperty(\"BankerNatural\"))\n                if (!$util.isString(message.BankerNatural))\n                    return \"BankerNatural: string expected\";\n            if (message.PlayerNatural != null && message.hasOwnProperty(\"PlayerNatural\"))\n                if (!$util.isString(message.PlayerNatural))\n                    return \"PlayerNatural: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a BetStatus message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof table.BetStatus\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {table.BetStatus} BetStatus\n         */\n        BetStatus.fromObject = function fromObject(object) {\n            if (object instanceof $root.table.BetStatus)\n                return object;\n            let message = new $root.table.BetStatus();\n            if (object.Banker != null)\n                message.Banker = String(object.Banker);\n            if (object.Player != null)\n                message.Player = String(object.Player);\n            if (object.Tie != null)\n                message.Tie = String(object.Tie);\n            if (object.BankerPair != null)\n                message.BankerPair = String(object.BankerPair);\n            if (object.PlayerPair != null)\n                message.PlayerPair = String(object.PlayerPair);\n            if (object.BankerNatural != null)\n                message.BankerNatural = String(object.BankerNatural);\n            if (object.PlayerNatural != null)\n                message.PlayerNatural = String(object.PlayerNatural);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BetStatus message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof table.BetStatus\n         * @static\n         * @param {table.BetStatus} message BetStatus\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BetStatus.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.Banker = \"\";\n                object.Player = \"\";\n                object.Tie = \"\";\n                object.BankerPair = \"\";\n                object.PlayerPair = \"\";\n                object.BankerNatural = \"\";\n                object.PlayerNatural = \"\";\n            }\n            if (message.Banker != null && message.hasOwnProperty(\"Banker\"))\n                object.Banker = message.Banker;\n            if (message.Player != null && message.hasOwnProperty(\"Player\"))\n                object.Player = message.Player;\n            if (message.Tie != null && message.hasOwnProperty(\"Tie\"))\n                object.Tie = message.Tie;\n            if (message.BankerPair != null && message.hasOwnProperty(\"BankerPair\"))\n                object.BankerPair = message.BankerPair;\n            if (message.PlayerPair != null && message.hasOwnProperty(\"PlayerPair\"))\n                object.PlayerPair = message.PlayerPair;\n            if (message.BankerNatural != null && message.hasOwnProperty(\"BankerNatural\"))\n                object.BankerNatural = message.BankerNatural;\n            if (message.PlayerNatural != null && message.hasOwnProperty(\"PlayerNatural\"))\n                object.PlayerNatural = message.PlayerNatural;\n            return object;\n        };\n\n        /**\n         * Converts this BetStatus to JSON.\n         * @function toJSON\n         * @memberof table.BetStatus\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BetStatus.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BetStatus;\n    })();\n\n    return table;\n})();\n\nexport { $root as default };\n","\r\nimport {sendWSPush} from \"./webSocket\"\r\nimport protoRoot from '@/assets/js/bundle'\r\nimport store from './store' //在元件之外要使用store，不能用useStore\r\nimport router from \"./router\"\r\n//proto型態\r\nconst foundation = protoRoot.foundation\r\nconst route = protoRoot.route.URI\r\nconst auth = protoRoot.auth\r\nconst lobby = protoRoot.lobby\r\nconst table = protoRoot.table\r\nconst bet = protoRoot.bet\r\nconst dealer = protoRoot.dealer\r\nconst game = protoRoot.game\r\nconst roadmap = protoRoot.roadmap\r\n//各種send方法\r\n//發送心跳\r\nconst sendPon = ()=>{\r\n    let proto = foundation.HeartbeatPong.create({\r\n        header:foundation.Header.create({\r\n            uri:route.HeartbeatPong\r\n        })\r\n    })\r\n    let bytes = foundation.HeartbeatPong.encode(proto).finish()\r\n    // console.log(\"sendPon\",proto)\r\n    sendWSPush(bytes)\r\n}\r\n//發送登入訊息\r\nexport const sendLogin =(data:any) => {\r\n    let proto = auth.LoginCall.create({\r\n        header:foundation.Header.create({\r\n            uri:route.LoginCall\r\n        }),\r\n        token:data.token,\r\n    })\r\n    let bytes = auth.LoginCall.encode(proto).finish()\r\n    // console.log(\"sendLogin\",proto)\r\n    sendWSPush(bytes);\r\n}\r\n//發送選桌訊息\r\nexport const sendTableJoinCall =(data:any) => {\r\n    let proto = table.TableJoinCall.create({\r\n        header:foundation.Header.create({\r\n            uri:route.TableJoinCall\r\n        }),\r\n        uuid:data.uuid\r\n    })\r\n    let bytes = table.TableJoinCall.encode(proto).finish()\r\n    // console.log(\"sendTableJoinCall\",proto)\r\n    sendWSPush(bytes);\r\n}\r\n//發送下注資訊\r\nexport const sendBetCall = (data:any) => {\r\n    let proto = bet.BetCall.create({\r\n        header:foundation.Header.create({\r\n            uri:route.BetCall\r\n        }),\r\n        gameUuid:data.gameUuid,\r\n        betIndex:data.betIndex,\r\n        betArea:data.betArea,\r\n    })\r\n    let bytes = bet.BetCall.encode(proto).finish()\r\n    console.log(\"sendBetCall\",proto)\r\n    sendWSPush(bytes);\r\n}\r\n//發送下注重置\r\nexport const sendBetResetCall = (data:any) => {\r\n    let proto = bet.BetResetCall.create({\r\n        header:foundation.Header.create({\r\n            uri:route.BetResetCall\r\n        }),\r\n        gameUuid:data.gameUuid,\r\n    })\r\n    let bytes = bet.BetResetCall.encode(proto).finish()\r\n    // console.log(\"sendBetResetCall\",proto)\r\n    sendWSPush(bytes);\r\n}\r\n\r\n\r\n\r\n//各種接收訊息的方法，在main.js中全局註冊監聽\r\nexport const getMsgReCall = (e:any) =>{\r\n    let header = foundation.Message.decode(new Uint8Array(e.detail.msg.data)).header\r\n    switch(header?.uri){\r\n        case route.HeartbeatPing:\r\n            // console.log(\"接收ping\")\r\n            sendPon()\r\n            break\r\n        case route.LoginRecall:\r\n            let loginRecall = auth.LoginRecall.decode(new Uint8Array(e.detail.msg.data))\r\n            // console.log('LoginRecall',loginRecall)\r\n            store.commit('auth/LoginRecall',loginRecall)\r\n            break\r\n        case route.LobbyInfo:\r\n            let lobbyInfo = lobby.LobbyInfo.decode(new Uint8Array(e.detail.msg.data))\r\n            // console.log('lobbyInfo',lobbyInfo)\r\n            store.commit('lobby/LobbyInfo',lobbyInfo)\r\n            break\r\n        case route.UserInfo:\r\n            let UserInfo = auth.UserInfo.decode(new Uint8Array(e.detail.msg.data))\r\n            // console.log('UserInfo',UserInfo)\r\n            store.commit('auth/UserInfo',UserInfo)\r\n            break\r\n        case route.TableJoinRecall:\r\n            let TableJoinRecall = table.TableJoinRecall.decode(new Uint8Array(e.detail.msg.data))\r\n            console.log('TableJoinRecall',TableJoinRecall)\r\n            store.commit('table/TableJoinRecall',TableJoinRecall)\r\n            break\r\n    }\r\n}","import { createApp } from 'vue'\r\nimport App from './App.vue'\r\nimport router from './router'\r\nimport store from './store'\r\nimport './assets/css/all.css';  \r\nimport { getMsgReCall } from './socketApi'\r\nNodePlayer.load(()=>{\r\n    createApp(App).use(store).use(router).mount('#app')\r\n})\r\nwindow.addEventListener('onmessageWs',getMsgReCall)  //全局註冊wbSocket的訊息監聽"],"sourceRoot":""}